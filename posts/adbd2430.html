<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Redis面试题 | 北川的个人博客</title><meta name="keywords" content="Redis"><meta name="author" content="北川,1656473414@qq.com"><meta name="copyright" content="北川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Redis面试题"><meta name="application-name" content="Redis面试题"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Redis面试题"><meta property="og:url" content="https://gukeyang.github.io/posts/adbd2430.html"><meta property="og:site_name" content="北川的个人博客"><meta property="og:description" content="Redis 是面试中的高频考点，重点集中在 数据结构、持久化机制、高可用（主从 &amp;#x2F; 哨兵 &amp;#x2F; 集群）、缓存问题（穿透 &amp;#x2F; 击穿 &amp;#x2F; 雪崩）、性能优化 等方面。 什么是RedisRedis（Remote Dictionary Server）是一个开源的高性能键值"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=cdc92548-a3c3-d014-7322-6a9bc2cd18dd"><meta property="article:author" content="北川"><meta property="article:tag" content="博客,笔记,学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=cdc92548-a3c3-d014-7322-6a9bc2cd18dd"><meta name="description" content="Redis 是面试中的高频考点，重点集中在 数据结构、持久化机制、高可用（主从 &amp;#x2F; 哨兵 &amp;#x2F; 集群）、缓存问题（穿透 &amp;#x2F; 击穿 &amp;#x2F; 雪崩）、性能优化 等方面。 什么是RedisRedis（Remote Dictionary Server）是一个开源的高性能键值"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://gukeyang.github.io/posts/adbd2430"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":"3932F24FA213E964B6B1B0FD091F88CE"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: 北川","link":"链接: ","source":"来源: 北川的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '北川的个人博客',
  title: 'Redis面试题',
  postAI: '',
  pageFillDescription: '什么是Redis, Redis系统架构模型, Redis为什么快, Redis的基本数据类型, Redis各数据类型有哪些应用场景？, Redis 中 set和zset区别是什么？, Redis哪些地方使用了多线程?, Redis怎么实现的io多路复用？, 如何实现redis 原子性？, 1. 单线程执行模型：单个命令的天然原子性, 2. 事务（MULTIx2FEXEC）：多命令的原子性打包, 3. Lua 脚本：复杂逻辑的原子性, 4. 原生原子命令：高频场景的简化支持, Redis 事务的基本命令有哪些？执行流程？, Redis的持久化, AOF 日志, 工作流程, 关键机制, 优缺点, RDB 快照, 触发方式, 优缺点, 缓存淘汰和过期删除, 一、过期删除策略（处理已过期的键）, 1. 惰性删除（Lazy Expiration）, 2. 定期删除（Periodic Expiration）, 二、缓存淘汰策略（内存不足时淘汰键）, 1. 只淘汰 设置了过期时间 的键（volatile-*）, 2. 淘汰所有键（包括未设置过期时间的allkeys-*）, 3. 不淘汰键（noeviction）, 主从同步中的增量和完全同步怎么实现？, 完全同步, 增量同步, Redis主从和集群可以保证数据一致性吗 ？, 一、主从架构的一致性问题, 二、Redis Cluster（集群）的一致性问题, Redis 哨兵（Sentinel）机制, 一、哨兵的核心功能, 二、哨兵的架构设计, 三、哨兵的工作原理（核心流程）, 1. 监控与状态判断（节点健康检测）, 2. 故障转移触发（当主节点 客观下线 后）, 3. 新主节点选举（从从节点中选一个升级为主节点）, 4. 故障转移执行（更新拓扑结构）, 5. 原主节点恢复后的处理, Redis集群的模式了解吗 优缺点了解吗, 一、Redis 集群的核心模式（设计特点）, 1. 数据分片：基于哈希槽（Hash Slot）, 2. 主从复制与故障转移, 3. 去中心化设计, 4. 容错与可用性保障, 二、Redis 集群的优点, 三、Redis 集群的缺点, 四、适用场景与总结, 场景题(重点), 为什么使用redis?, 为什么redis比mysql要快?, 本地缓存和Redis缓存的区别?, redis应用场景是什么?, Redis分布式锁的实现原理?, 1. 加锁：通过SET命令的原子性实现, 2. 释放锁：通过 Lua 脚本保证原子性, 什么场景下用到分布式锁?, 1. 库存扣减（防止超卖）, 2. 定时任务（防止重复执行）, 3. 分布式事务（跨服务数据一致性）, 4. 共享资源修改（防止脏写）, 5. 分布式限流（控制全局并发量）, 6. 分布式 ID 生成（保证 ID 唯一性）, Redis的大Key问题是什么?, 大 Key 的具体表现形式, 具体缺点, 1. 阻塞 Redis 主线程降低整体吞吐量, 2. 内存分布不均影响集群负载均衡, 3. 网络带宽消耗激增, 4. 持久化与恢复效率低下, 5. 过期删除与内存淘汰成本高, 如何解决, 一、针对不同类型大 Key 的拆分策略, 1. String 类型大 Key（如大对象、长文本）, 2. Hash 类型大 Key（如包含大量字段的哈希表）, 3. Listx2FSetx2FZSet 类型大 Key（如包含大量元素的集合）, 二、删除大 Key 的特殊处理, 什么是热key?, 如何保证 redis 和 mysql 数据缓存一致性问题?, 一、核心原则：优先 删缓存而非 更缓存, 二、主流方案详解, 1. 旁路缓存模式（Cache-Aside Pattern）：先更 DB再删缓存, 2. 先删缓存再更 DB + 延迟双删, 3. 基于 Binlog 的异步同步（Canal 方案）, 4. 强一致性方案：加锁 + 双写, 三、必加兜底：缓存过期时间, 缓存雪崩、击穿、穿透是什么?怎么解决?, 布隆过滤器原理介绍一下, 如何设计秒杀场景处理高并发以及超卖现象?, 防超卖：库存操作的原子性与一致性, 1. 库存预热：Redis 预存库存（快速判断）, 2. Redis 原子扣减：拦截超量请求（核心防超卖）, 3. MySQL 最终校验：保证数据一致性（兜底机制）, 4. 库存一致性维护, 假如 Redis 里面有 1 亿个   key其中有 10w 个 key 是以 某个固定的已知的前缀开头的 如何将它们全部找出来？, MySQL 里有 2000w 数据  redis 中只存 20w 的数据如 何保证 redis 中的数据都是热点 数据？是面试中的高频考点重点集中在数据结构持久化机制高可用主从哨兵集群缓存问题穿透击穿雪崩性能优化等方面什么是是一个开源的高性能键值对数据库它将数据存储在内存中因此具有极高的读写速度同时也支持数据持久化到磁盘以防止数据丢失基于内存存储数据主要存于内存读写速度极快毫秒级响应适合高频访问场景支持多种数据结构不仅支持字符串还包括哈希列表集合有序集合位图地理空间等灵活满足不同业务需求持久化机制通过快照和日志追加两种方式将内存数据持久化到磁盘平衡性能与数据安全性高并发与扩展性支持主从复制哨兵模式和集群可实现高可用和水平扩展应对海量请求丰富的功能提供事务发布订阅脚本过期键自动删除等功能适合缓存计数器消息队列排行榜等场景系统架构模型采用单线程多路复用内存存储的核心读写操作由单个线程处理避免多线程上下文切换开销通过串行化处理命令保证原子性无需锁机制基于操作系统的多路复用机制如的的单线程可同时监听多个客户端连接的事件读写请求高效处理并发请求所有数据默认存储在内存中读写速度极快微秒级响应远超磁盘数据库为什么快的大部分操作都是基于内存完成的并且采用了高效的数据结构因此瓶颈可能是机器的内存和网络带宽采用单线程的话避免了多线程之间的竞争省去了多线程切换带来的时间和性能上的开销采用了多路复用机制处理大量的客户端请求多路复用机制是指一个线程处理多个流就是我们经常听到机制简单来说在只运行单线程的情况下该机制允许内核中同时存在多个监听和已连接内核会一直监听这些上的连接请求或数据请求一旦有请求到达就会交给线程处理这就实现了一个线程处理多个流的效果的基本数据类型数据类型核心特性常用命令示例典型应用场景字符串存储文本数字二进制数据最大支持原子操作和过期时间缓存简单数据用户信息计数器阅读量分布式锁哈希键值对集合适合存储对象可单独操作字段节省内存存储对象信息用户资料商品属性列表有序可重复元素双向操作底层为链表压缩列表消息队列最新列表朋友圈动态栈队列实现集合无序不可重复元素支持交集并集差集查找效率交集并集标签系统文章标签好友关系共同好友去重操作有序集合元素关联分数按分数排序支持范围查询底层为跳表升序降序排行榜游戏积分销量排名优先级队列范围统计分数区间用户位图二进制位操作扩展适合存储布尔值序列节省空间设定位获取位统计的个数用户签到在线状态权限标记地理空间存储经纬度支持距离计算范围查询添加坐标计算距离查找范围内元素附近的人服务附近门店流专为消息队列设计支持持久化消费确认分组消费添加消息读取消息创建消费组高可靠消息队列日志收集异步任务近似统计基数不重复元素数占用内存极小约误差率低添加元素统计基数合并多个海量数据去重统计计数访问去重各数据类型有哪些应用场景在互联网产品中使用的场景实在是太多太多这里分别对几种数据类型做了整理缓存限流分布式锁计数器分布式等用户信息用户主页访问量组合查询等简单队列关注列表时间轴赞踩标签等排行榜好友关系链表中和区别是什么对比维度集合有序集合有序性无序元素存储和返回的顺序与插入顺序无关底层哈希表实现有序每个元素关联一个分数元素按分数升序排列底层跳表哈希表实现元素唯一性元素不可重复重复插入会被忽略元素不可重复重复插入会覆盖原元素的分数但分数可以重复核心特性侧重去重和集合运算交集并集差集侧重排序和范围查询按分数筛选取前名等常用命令添加查所有交集判断存在添加需指定分数升序查降序查查分数分数自增查询效率单元素查询但无法按顺序或范围批量查询只能全量获取支持按分数范围查询如时间复杂度为总数为结果数效率高内存占用仅存储元素本身内存占用较低需额外存储每个元素的分数内存占用略高于哪些地方使用了多线程网络处理引入了多线程处理网络主要解决网络读写瓶颈问题主线程负责命令的解析执行和结果处理而网络数据的读取和写入由专门的线程处理异步删除大键当删除超大键如包含百万级元素的哈希表列表时直接删除会阻塞主线程引入了后台线程线程异步处理删除操作使用命令替代时会将删除操作丢给后台线程主线程无需等待继续处理其他命令类似的等异步清空命令也依赖后台线程执行日志刷盘操作持久化中数据先写入内存缓冲区再定期刷到磁盘其中系统调用将缓冲区数据强制写入磁盘可能阻塞主线程因此提供了多线程选项配置时会使用后台线程每隔秒执行一次避免主线程阻塞持久化部分阶段持久化通过子进程生成快照子进程负责写入数据到磁盘不影响主线程虽然本身是单线程操作主线程短暂阻塞但子进程的写入过程本质上是独立的线程进程行为可视为多进程线程协作的场景怎么实现的多路复用这里的多路指的其实是多个网络连接客户端复用指的是同一个线程多路复用其实是使用一个线程来检查多个的就绪状态在单个线程中通过记录跟踪每一个的状态来管理处理多个流如何实现原子性原子性的核心是单线程串行执行在此基础上通过事务脚本扩展多命令原子性并用原生命令覆盖高频场景兼顾效率与一致性单线程执行模型单个命令的天然原子性的核心命令执行是单线程的网络等辅助操作可多线程但命令逻辑串行这意味着同一时间只会执行一个命令不会有并行修改冲突单个命令从读取处理到结果写入的全过程不会被其他命令打断因此所有单个命令本身就是原子操作比如等事务多命令的原子性打包当需要多个命令作为整体执行时用事务机制流程开启事务后续命令入队不执行触发所有命令按顺序原子执行原子性保证执行期间单线程会串行处理队列中所有命令中间不会插入其他客户端命令若入队时有语法错误事务会整体取消注意事务不支持回滚执行中某命令失败其他仍会继续主要保证要么全执行要么全不执行脚本复杂逻辑的原子性对于需要依赖中间结果的复杂逻辑如带条件判断用脚本原理整个脚本会被作为单个单元执行执行期间不会被任何其他命令打断优势支持等逻辑比事务更灵活一次脚本调用完成多命令减少网络开销原生原子命令高频场景的简化支持针对常见场景设计了原生原子命令避免用户手动组合命令的风险比如原子性完成读改写自增仅当不存在时设置值原子性实现加锁原子性转移列表元素事务的基本命令有哪些执行流程核心命令开启事务执行事务队列放弃事务清空队列监视键实现乐观锁执行流程用开启事务客户端进入命令入队模式后续命令不会立即执行而是被放入事务队列返回执行时按顺序原子性执行队列中所有命令若执行则清空队列放弃事务的持久化为了保证内存中的数据不会丢失实现列数据了持久化机制这个机制会把数据存储在磁盘这样在重启能够恢复数据日志是命令日志记录所有写操作命令如等以文本形式追加到文件默认恢复时会重新执行日志中的所有命令重建数据工作流程命令追加执行写命令后先将命令追加到内存中的缓冲区避免频繁文件写入缓冲区数据定期同步到磁盘文件同步策略可配置文件重写文件会随命令增多而变大通过重写机制压缩合并重复命令如多次合并为最终值的关键机制同步策略通过配置平衡安全性和性能每个命令执行后立即同步到磁盘安全性最高但开销大性能差每秒同步一次默认最多丢失秒数据平衡安全与性能由操作系统决定何时同步性能最好但可能丢失大量数据重写解决文件过大问题触发方式手动执行或自动触发配置和当文件大小超过阈值且增长比例达标时触发过程主线程子进程子进程遍历内存数据生成新的日志只保留最终状态的命令期间新命令会写入重写缓冲区重写完成后合并到新文件替换旧文件优缺点优点数据安全性高可通过配置将数据丢失控制在秒内日志是文本命令易理解和修复如误操作可手动编辑日志删除错误命令缺点文件体积大文本命令无压缩恢复速度慢需重新执行所有命令重写时子进程有开销且高并发下策略可能导致短暂阻塞同步时若磁盘慢主线程会等待快照是某一时刻内存数据的二进制快照类似照片将当前内存中所有键值对以压缩的二进制形式写入磁盘默认文件恢复时直接加载该文件到内存即可触发方式手动触发主线程直接执行快照期间会阻塞所有客户端请求不推荐可能导致卡顿主线程一个子进程由子进程负责写入文件主线程继续处理命令非阻塞推荐自动触发通过配置文件配置表示秒内有次键修改时自动触发其他场景主从复制时主节点自动触发执行命令且未开启时会触发确保数据落地优缺点优点文件体积小二进制压缩恢复速度快直接加载到内存无需解析命令不阻塞主线程对性能影响小缺点数据安全性低快照间隔期间若崩溃会丢失这段时间的数据如配置则可能丢失秒内的数据的操作有开销子进程时需复制父进程的内存页表若内存大可能短暂阻塞主线程缓存淘汰和过期删除中的过期删除和缓存淘汰是两个关联但不同的机制前者解决过期键如何被清理的问题后者解决内存不足时如何淘汰键以释放空间的问题两者共同保证了高效利用内存并维持数据有效性一过期删除策略处理已过期的键允许为键设置过期时间如表示秒后过期当键过期后需要通过特定策略将其从内存中删除采用惰性删除定期删除的混合策略而非立即删除避免频繁删除对性能的影响惰性删除原理键过期后不会主动删除而是在下次被访问时才检查是否过期若过期则删除并返回否则正常返回值优点无需额外消耗监控过期键只在必要时处理对性能影响小缺点若过期键长期未被访问会一直占用内存可能导致内存泄漏定期删除原理每隔一段时间默认左右会主动扫描部分过期键并删除具体流程从过期键字典记录所有键的过期时间中随机抽取部分键删除其中已过期的键若删除比例超过则重复步骤避免大量过期键堆积否则结束本轮扫描优点主动清理部分过期键减少惰性删除导致的内存浪费缺点扫描频率和范围需控制避免长时间阻塞主线程通过限制每次扫描的时间默认不超过来平衡性能二缓存淘汰策略内存不足时淘汰键当内存使用达到配置的阈值时会触发缓存淘汰策略淘汰部分键以释放内存即使这些键未过期提供种淘汰策略可通过配置核心分为三大类只淘汰设置了过期时间的键淘汰最近最少使用的过期键淘汰最近最不常用的过期键比多统计访问频率淘汰剩余过期时间最短的键随机淘汰过期键淘汰所有键包括未设置过期时间的淘汰所有键中最近最少使用的键淘汰所有键中最近最不常用的键随机淘汰所有键中的键不淘汰键默认策略不淘汰任何键当内存不足时拒绝所有新的写操作返回错误读操作正常主从同步中的增量和完全同步怎么实现完全同步完全同步发生在以下几种情况从节点首次连接主节点无主节点的和同步偏移量从节点重连时主节点的已变化如主节点重启从节点的不在主节点的复制积压缓冲区范围内同步流程从节点发起请求从节点发送命令表示未知主节点表示无主节点生成主节点收到请求后执行生成全量数据的快照异步执行不阻塞主节点处理新命令同时将生成期间的所有写命令记录到复制缓冲区每个从节点独立维护发送给从节点主节点将文件发送给从节点从节点接收后清空自身原有数据加载文件此过程会阻塞从节点无法处理读请求同步缓冲命令发送完成后主节点将复制缓冲区中记录的生成期间的写命令发送给从节点从节点执行这些命令最终与主节点数据完全一致增量同步增量同步是指主从节点已完成过完全同步后续因网络短暂中断等原因重连时主节点仅向从节点发送从节点缺失的那部分命令而非全量数据以减少资源消耗正常同步阶段主节点处理写命令时会将命令同步给从节点同时更新自身并将命令写入复制积压缓冲区从节点接收命令后执行更新自身网络中断与重连网络中断后主节点继续处理命令并写入复制积压缓冲区从节点暂停同步网络恢复后从节点发送命令携带记录的主节点和自身当前增量同步验证主节点检查是否匹配确认是同一主节点并判断从节点的是否在复制积压缓冲区的范围内即缓冲区起始位置若验证通过主节点从开始将缓冲区中后续的命令发送给从节点从节点执行后更新完成增量同步主从和集群可以保证数据一致性吗的主从架构和集群不能保证强一致性但能在大多数场景下保证最终一致性其数据一致性的保障程度受架构设计同步机制和配置参数的影响存在一定的局限性一主从架构的一致性问题主从架构一主多从的核心是主节点写入从节点复制但同步机制的本质决定了它无法保证强一致性异步复制的天然缺陷主节点处理写命令后会立即返回结果给客户端不会等待从节点同步完成此时若主节点突然宕机未同步到从节点的命令会丢失从节点提升为主节点后这部分数据会永久缺失导致数据不一致配置优化的局限性虽然提供了一些参数减少数据丢失风险如要求主节点必须有至少个从节点在时间内完成同步才允许写入但这只能降低丢失概率无法完全避免如主从网络突然中断时主节点可能已接受写入但未同步从节点读取的滞后性从节点默认允许读操作但由于同步存在延迟即使毫秒级客户端可能从从节点读取到旧数据出现读写不一致二集群的一致性问题通过分片将数据分散到多个主节点每个主节点有从节点作为备份其一致性问题本质与主从架构类似且新增了分片间的协调问题分片内的异步复制集群中每个分片主节点从节点的同步机制与主从架构一致仍是异步复制主节点写入后立即返回未同步的命令在主节点宕机时可能丢失导致分片内数据不一致故障转移的数据缺口当主节点故障时从节点通过选举成为新主节点若从节点未完全同步主节点的最新数据如同步延迟或网络中断新主节点的数据会存在缺口与客户端预期的最新数据不一致跨分片操作的一致性集群中跨分片的命令如涉及多个分布在不同分片是非原子的可能部分分片执行成功部分失败导致跨分片数据不一致不支持分布式事务无法保证跨分片操作的原子性最终一致性的前提只有在网络稳定无节点故障同步延迟可接受的情况下集群内各节点的数据才会逐渐趋于一致最终一致性但极端场景如网络分区节点频繁故障可能导致长时间的数据不一致哨兵机制哨兵机制是官方提供的高可用解决方案主要用于监控主从架构中的节点状态并在主节点故障时自动完成故障转移确保服务持续可用一哨兵的核心功能哨兵机制通过一组通常为个及以上哨兵进程协同工作实现以下功能监控持续检查主节点和从节点是否正常运行自动故障转移当主节点故障时自动将一个从节点升级为新主节点并让其他从节点切换到新主节点进行复制通知当节点状态变化如主节点下线故障转移完成时通过如的发布订阅机制通知管理员或客户端配置管理客户端通过哨兵获取当前主节点的地址无需硬编码主节点信息当主节点切换后客户端可自动获取新主节点地址二哨兵的架构设计哨兵机制通常采用多哨兵集群而非单个哨兵原因是单个哨兵可能因自身故障误判主节点状态而多哨兵通过共识机制可减少误判提高可靠性典型架构如下个主节点个从节点主从复制架构个哨兵节点且为奇数便于选举决策哨兵节点之间相互通信同时也与所有主从节点保持连接三哨兵的工作原理核心流程哨兵的工作过程可分为监控与状态判断故障转移触发新主节点选举配置更新四个阶段监控与状态判断节点健康检测哨兵通过定期发送命令与主从节点通信判断节点是否存活核心涉及两个状态主观下线单个哨兵向某节点主或从发送命令如果在配置的时间内未收到有效响应如超时错误回复则该哨兵认为此节点主观下线仅自身判断可能存在误判客观下线仅针对主节点当一个哨兵判断主节点主观下线后会向其他哨兵发送命令询问它们是否也认为该主节点下线如果超过配置的最小哨兵数量个哨兵均认为主节点主观下线则该主节点被标记为客观下线达成共识确认故障故障转移触发当主节点客观下线后主节点被标记为客观下线后哨兵集群会启动故障转移流程核心是先选举一个哨兵领导者由它负责执行后续的故障转移操作避免多个哨兵同时操作导致混乱哨兵领导者选举采用类似算法的选举机制每个哨兵向其他哨兵发送命令请求将自己选为领导者每个哨兵在一轮选举中只能投票给一个候选者若某哨兵获得超过半数为哨兵总数的选票则成为领导者若一轮选举未产生领导者等待一段时间后重新选举直到选出领导者新主节点选举从从节点中选一个升级为主节点哨兵领导者需从原主节点的所有从节点中选择一个最优的从节点升级为新主节点选择标准如下优先级从高到低排除不健康的从节点过滤掉主观下线连接断开时间过长超过的从节点优先级最高的从节点通过配置默认值越小优先级越高优先选择优先级高的复制进度最完整的从节点选择与原主节点的复制偏移量最接近的从节点即数据最新的运行时间最久的从节点若前两项相同选择节点唯一标识最小的启动时间最早故障转移执行更新拓扑结构选定新主节点后哨兵领导者执行以下操作完成故障转移向新主节点发送命令使其停止作为从节点升级为主节点向其他所有从节点发送新主节点新主节点端口命令让它们切换到新主节点进行复制更新哨兵集群的配置信息记录新主节点的地址从节点列表等并通过发布订阅机制频道同步给所有哨兵通知客户端通过客户端订阅的哨兵频道新主节点的地址客户端后续将请求发送到新主节点原主节点恢复后的处理若原主节点故障节点恢复上线哨兵会将其自动转为新主节点的从节点避免其再次成为主节点导致冲突集群的模式了解吗优缺点了解吗集群是官方提供的分布式解决方案主要用于解决单机的容量瓶颈内存上限和高可用问题支持数据分片自动故障转移和水平扩展其核心设计围绕分片存储和去中心化高可用展开以下是其模式细节及优缺点分析一集群的核心模式设计特点集群的核心目标是实现大规模数据的分布式存储和自动化的高可用保障其关键机制包括数据分片基于哈希槽集群将数据分散存储在多个节点上核心通过哈希槽实现分片总共有个哈希槽固定值范围每个槽对应一部分数据集群中的每个主节点负责一部分哈希槽例如个主节点可能分别负责个槽数据分配规则对键计算哈希值得到对应的哈希槽该键就存储在负责此槽的主节点上这种设计的优势是分片规则简单客户端可直接计算键所在的节点无需通过中心节点转发支持动态调整槽分配例如新增节点时可将部分槽从旧节点迁移到新节点实现水平扩展主从复制与故障转移为保证高可用集群中每个主节点会配置个或多个从节点形成一主多从的分片单元从节点复制主节点的数据作为备份当主节点故障如宕机网络中断时集群会自动从其从节点中选举一个升级为新主节点接管原主节点的哈希槽整个过程无需人工干预类似哨兵机制但集成在集群内部去中心化设计集群中没有中心节点所有节点主从通过协议相互通信节点定期交换状态信息如自身健康状态负责的槽主从关系等维护整个集群的元数据如哪个节点负责哪些槽客户端连接集群时只需与任意一个节点通信即可获取全量的槽分配信息进而直接与目标节点交互容错与可用性保障集群通过投票机制判断节点是否故障当超过半数的主节点认为某个节点不可达时标记该节点为故障若主节点故障且无可用从节点集群会进入部分可用状态仅故障节点负责的槽不可用其他槽正常服务支持配置默认若设为即使部分槽不可用集群仍允许其他槽的读写二集群的优点水平扩展能力强支持动态增加节点主从通过迁移哈希槽实现数据负载均衡理论上可无限扩展受限于实际部署成本解决了单机的内存和上限问题高可用内置化集成了主从复制和自动故障转移功能无需额外部署哨兵主节点故障后自动切换从节点为新主减少服务中断时间去中心化无单点瓶颈节点间通过协议平等通信无中心节点避免了中心节点的性能或故障瓶颈分片规则高效基于哈希槽的分片逻辑简单客户端可直接定位键所在节点减少转发开销槽迁移过程中数据可正常访问通过重定向机制适合大规模数据场景相比主从架构全量数据复制集群通过分片将数据分散存储每个节点仅存储部分数据降低了单节点的存储压力三集群的缺点数据一致性无法保证异步复制缺陷主节点向从节点的复制是异步的主节点写入后立即返回客户端不等待从节点同步若主节点故障未同步到从节点的数据会丢失只能保证最终一致性不适合强一致性场景不支持跨槽的复杂命令涉及多个键的命令如若这些键分布在不同哈希槽集群会直接返回错误需通过客户端手动将键哈希标签如和强制分配到同一槽增加了开发复杂度运维复杂度高节点扩容缩容时需手动迁移哈希槽或依赖工具过程中需确保数据一致性集群元数据槽分配主从关系维护复杂故障排查难度高于主从架构对网络稳定性要求高协议的信息同步依赖网络网络分区可能导致集群状态判断混乱内存和网络开销较大每个节点需存储全量的集群元数据槽分配节点列表等节点越多元数据开销越大协议的定期信息交换会消耗额外网络带宽尤其是节点数量较多时兼容性限制部分功能在集群模式下受限不支持事务跨多个节点不支持等全局命令需指定节点执行对脚本的支持有限脚本中涉及的键必须在同一槽四适用场景与总结适用场景需要存储大规模数据超过单机内存要求高可用性自动故障转移可接受最终一致性的场景如电商缓存用户会话存储分布式计数器不适用场景强一致性需求如金融交易依赖大量跨键命令如复杂的多键事务小规模数据且追求简单运维的场景此时主从哨兵更合适场景题重点为什么使用主要是因为具备高性能和高并发两种特性具备高性能假如用户第一次访问中的某些数据这个过程会比较慢因为是从硬盘上读取的将该用户访问的数据缓存在中这样下一次再访问这些数据的时候就可以直接从缓存中获取了操作缓存就是直接操作内存所以速度相当快如果中的对应数据改变的之后同步改变缓存中相应的数据即可不过这里会有和双写一致性的问题具备高并发单台设备的的每秒钟处理完请求的次数是的倍单机的能轻松破而单机的很难破所以直接访问能够承受的请求是远远大于直接访问的所以我们可以考虑把数据库中的部分数据转移到缓存中去这样用户的一部分请求会直接到缓存这里而不用经过数据库为什么比要快内存存储是基于内存存储的数据库而是基于磁盘存储的关系型数据库由于内存存储速度快能够更快地读取和写入数据而无需像那样频繁进行磁盘操作简单数据结构是基于键值对存储数据的支持简单的数据结构字符串哈希列表集合有序集合相比之下需要定义表结构索引等复杂的关系型数据结构因此在某些场景下的数据操作更为简单高效比如用哈希表查询只需要时间复杂度而引擎的底层实现是时间复杂度是线程模型采用单线程模型可以避免了多线程之间的竞争省去了多线程切换带来的时间和性能上的开销而且也不会导致死锁问题本地缓存和缓存的区别本地缓存的核心优势是极致性能无网络开销和部署简单但局限于单机无法共享容量有限缓存的核心优势是分布式共享能力和可扩展性但存在网络延迟和额外的运维成本应用场景是什么热点数据缓存电商商品详情用户基本信息新闻列表首页推荐数据分布式计数器基于的等原子命令实现跨服务高并发的计数功能无需担心并发竞争问题文章阅读量视频播放量商品点赞数秒杀活动库存计数接口调用次数统计分布式会话存储在分布式系统中多台应用服务器用户无法通过本地内存共享可作为集中式会话存储实现跨服务器的同步网站登录状态用户登录令牌如存储有序排行榜用的有序集合数据结构天然支持按分数排序可高效实现实时排行榜功能游戏玩家积分排名直播平台礼物榜电商商品销量榜社区话题热度榜简单消息队列通过发布订阅或功能实现轻量级消息通知或异步任务处理适合对消息可靠性要求不极致的场景用户注册后的短信邮件通知系统日志实时收集微服务间简单通信分布式锁基于的仅不存在时设置过期时间命令的原子性实现跨服务跨机器的资源互斥访问解决分布式环境下的并发冲突秒杀库存扣减防止超卖定时任务防止多实例重复执行跨服务修改同一条数据防止脏写哈希表存储结构化数据如购物车的下商品为数量为支持单独增删改某个字段无需操作整个对象分布式锁的实现原理分布式锁是用于分布式环境下并发控制的一种机制用于控制某个资源在同一时刻只能被一个应用所使用加锁通过命令的原子性实现加锁的核心命令是各参数含义锁的标识如表示订单的锁随机值如用于唯一标识当前加锁的线程服务避免释放锁时误删其他线程的锁仅当不存在时才设置成功保证互斥性同一时间只有一个线程能加锁设置锁的过期时间为秒防止死锁即使持有锁的线程崩溃锁也会自动释放加锁逻辑若命令返回表示加锁成功若返回表示锁已被其他线程持有加锁失败释放锁通过脚本保证原子性释放锁时不能直接用可能误删其他线程的锁需先验证当前锁的持有者是否为自己再删除这两步操作需通过脚本原子执行脚本逻辑若的值等于传入的则删除锁返回否则返回执行脚本时传入参数锁标识加锁时的当前线程的唯一标识释放逻辑若锁的与当前线程的一致说明锁是自己的执行删除释放成功若不一致说明锁已被其他线程持有可能是自己的锁过期后被别人加锁不做操作避免误删什么场景下用到分布式锁库存扣减防止超卖场景电商秒杀限量商品抢购等场景中多个用户同时下单需扣减同一商品的库存问题若没有分布式锁多个服务实例可能同时读取到剩余件库存并各自执行扣减导致最终库存为超卖分布式锁的作用保证同一时间只有一个请求能执行查库存扣减库存的逻辑避免并发冲突定时任务防止重复执行场景分布式系统中多个服务实例部署了相同的定时任务如每日数据统计订单超时关闭问题若没有锁所有实例会在同一时间执行任务导致重复计算如同一批订单被多次标记为超时关闭浪费资源且可能引发数据异常分布式锁的作用任务触发时多个实例竞争同一把锁只有抢到锁的实例执行任务其他实例放弃保证任务仅执行一次分布式事务跨服务数据一致性场景跨多个服务的事务操作如下单需同时扣减库存扣减余额生成订单需保证操作的原子性要么全成功要么全回滚问题若中间某一步失败如扣减余额超时其他服务可能已完成操作导致数据不一致分布式锁的作用通过锁约束整个事务流程确保只有一个进程能处理该业务如同一订单的事务失败时可安全回滚所有操作避免部分成功的中间状态共享资源修改防止脏写场景多个服务实例同时修改同一条共享数据如用户的积分账户余额配置项问题并发修改可能导致覆盖写如服务读取余额并加服务同时读取并加最终结果可能为而非分布式锁的作用保证读取修改写入的原子性同一时间只有一个服务能修改数据避免脏写分布式限流控制全局并发量场景限制某个接口的全局并发请求数如同一时间最多允许个请求访问支付接口问题单机限流如每个实例限并发无法控制全局总量个实例可能同时达到总并发但实际想限制的是全局不超过分布式锁的作用通过锁的竞争机制控制并发数如每次请求获取锁释放锁时计数减超过阈值则拒绝实现全局统一的限流分布式生成保证唯一性场景生成全局唯一如订单号流水号通常基于计数器时间戳实现问题多个服务实例同时读取计数器并自增可能生成重复如同时读取到计数器值都生成的大问题是什么的大问题指的是中某个对应的过大或集合类如包含过多元素导致性能下降运维困难甚至服务不稳定的现象没有绝对标准通常结合业务场景和性能表现判断常见参考阈值类型大小超过甚至即可视为大如序列化后的大对象长文本集合类型元素数量超过万甚至或整体占用内存超过如包含百万用户的存储大量订单明细的大的具体表现形式大例如存储整个网页序列化的大对象如包含数百个字段的用户信息长日志等大例如以用户为存储该用户的所有行为记录字段数过万大例如存储某热门话题的所有评论元素数几十万大例如存储某大型活动的所有参与用户元素数上百万具体缺点阻塞主线程降低整体吞吐量的核心命令处理是单线程的大的操作如大大大集合会占用大量时间阻塞后续所有命令的执行导致其他正常的请求延迟飙升从毫秒级增至秒级极端情况下单条大操作可能阻塞数秒引发客户端超时服务不可用内存分布不均影响集群负载均衡在集群中大会导致其所在的节点内存占用远高于其他节点数据倾斜该节点容易成为整个集群的性能瓶颈如内存使用率过高内存碎片化加剧大的频繁创建删除可能导致内存管理器产生大量碎片尤其是非连续内存分配降低实际内存利用率例如总内存使用率但可用内存可能仅剩网络带宽消耗激增读写大时需要传输大量数据如的每次需传输数据占用服务器与客户端主从节点之间的网络带宽在主从复制或集群数据迁移场景中大的同步迁移会持续占用网络资源导致从节点同步延迟数据落后主节点集群迁移超时大传输未完成触发迁移重试其他正常数据的网络传输被挤占延迟增加持久化与恢复效率低下持久化生成快照时大的序列化会消耗大量和资源导致文件生成时间过长甚至超时失败且大会增大文件体积占用更多磁盘空间持久化大的写命令如包含万字段会生成庞大的日志导致文件膨胀且刷盘时压力剧增数据恢复重启时加载文件解析大会耗时极长如加载包含万元素的可能需要数十秒导致服务启动缓慢可用性下降过期删除与内存淘汰成本高大过期时需要执行删除操作无论是主动删除还是惰性删除遍历大集合类的所有元素会消耗大量阻塞主线程当内存达到上限时内存淘汰机制如筛选和删除大会比小更耗时进一步加剧性能波动如何解决一针对不同类型大的拆分策略大的根本问题是单体积过大或元素过多拆分的核心是将一个大拆分为多个小分散存储压力类型大如大对象长文本问题单个的过大如以上例如序列化的完整用户信息长日志解决方案拆分对象字段将大对象拆分为多个小按字段存储例原个字段拆分为等每个仅存储一个字段优势减少单体积读取时按需获取字段避免一次性加载全量数据压缩存储对长文本如用压缩算法如压缩后再存入读取时解压适用场景文本压缩率高如重复内容多的日志且读写频率不极端避免压缩解压开销抵消收益按需缓存只缓存高频访问的核心字段非核心字段直接从数据库查询避免缓存冗余数据类型大如包含大量字段的哈希表问题的数量过多如万例如存储某用户的所有订单记录解决方案按字段范围拆分将一个大拆分为多个小按的特征如范围哈希值分配到不同的小中类型大如包含大量元素的集合问题的元素过多如万例如热门话题的评论列表的元素过多如百万例如活动参与用户集合解决方案按数量时间拆分集合按元素数量拆分如每个元素一个或按时间拆分如每天一个按元素的哈希值拆分如用户模分散到个中或按范围拆分如用户存存用替代做分页若用于分页查询如最新条评论可改用为时间戳按范围查询避免的操作遍历大量元素二删除大的特殊处理直接用命令删除大尤其是集合类会阻塞主线程单线程需遍历所有元素需用异步删除提供命令将大的删除操作放入后台线程执行主线程不阻塞仅记录删除任务后立即返回若使用低版本可分批删除集合元素如用每次删个元素循环执行直到集合为空避免单次操作耗时过长什么是热热热点指的是在短时间内被异常高频访问的键其访问量远高于其他普通导致该所在的节点或服务器承受巨大的负载压力甚至成为整个系统的性能瓶颈热的核心特征访问频率极高单位时间内的请求量远超其他例如某每秒被访问万次而普通仅几十次时间集中性访问往往集中在某个时间段爆发如秒杀活动开始时的商品突发热门事件的相关节点绑定在集群中热会固定落在负责其哈希槽的某个主节点上导致该节点成为热点节点举例说明电商平台的秒杀商品活动开始后用户同时刷新该商品详情对应的缓存如被高频访问社交平台的热门话题某事件突发后大量用户查询该话题内容对应的成为热直播平台的主播在线状态头部主播开播时粉丝同时查看其状态被频繁读取如何解决多副本存储热复制到多个节点将热复制到集群的多个节点主节点客户端访问时随机选择一个副本分散单个节点的压力本地缓存应用层缓存热在应用服务器的本地内存中缓存热如用用减少对的直接访问热拆分将一个热拆分为多个子若热的可拆分如计数集合将其拆分为多个子分散到集群的不同节点客户端访问时随机选择子操作读写分离主从扩容针对读热若热是读多写少类型可给其所在的主节点增加更多从节点将读请求分流到从节点减轻主节点压力如何保证和数据缓存一致性问题保证与的数据缓存一致性核心是解决缓存数据与数据库数据不同步的问题由于两者的存储特性内存磁盘和更新机制不同需根据业务对一致性的要求最终一致性强一致性读写频率等选择方案以下是经过实践验证的主流方案一核心原则优先删缓存而非更缓存直接更新缓存如容易引发并发冲突例如两个线程同时更新数据库若线程先更新缓存线程后更新缓存但的数据库更新晚于会导致缓存存的旧值更安全的做法是删除缓存让后续请求从数据库加载最新数据到缓存配合过期时间兜底即使偶发不一致缓存过期后也会自动同步二主流方案详解旁路缓存模式先更再删缓存适用场景读多写少对一致性要求为最终一致如商品详情用户信息流程读操作先查命中则返回未命中则查再将结果写入后返回写操作先更新再删除中对应的缓存而非更新缓存为什么有效删除缓存后后续读请求会从加载最新数据到自然恢复一致性潜在问题若更新成功但删除失败如网络波动会导致缓存留存旧数据解决方案重试机制删除缓存失败时将删除任务丢入消息队列如通过消费者重试删除设置次重试上限间隔递增如避免无效循环定时校验定时任务如每分钟对比缓存与的数据版本号需额外存储若缓存版本落后则删除缓存或重新同步先删缓存再更延迟双删适用场景写操作较频繁需避免缓存污染旧数据被误写入缓存解决的问题若删缓存后更新前有请求查询会从读旧数据并写入缓存导致后续不一致例如线程删除缓存开始更新未完成线程查询数据缓存已删查旧数据写入缓存线程更新完成此时缓存中是写入的旧数据不一致流程优化写操作先删缓存更新延迟一段时间如后再次删除缓存第二次删除的作用等线程完成查旧写旧缓存后再删一次缓存清除旧数据后续请求会从加载最新数据注意延迟时间需根据业务耗时调整如通过压测确定更新缓存写入的最大耗时通常设为基于的异步同步方案适用场景多服务共享数据缓存更新逻辑复杂如多表关联更新原理利用的日志记录所有数据库变更通过阿里开源工具监听实时感知变化异步更新删除缓存流程模拟从库订阅主库的数据更新时捕获变更事件如将事件推送给消息队列消费端根据事件更新删除对应的缓存优势解耦缓存更新逻辑业务代码无需嵌入删缓存逻辑支持多服务场景避免各服务重复处理缓存缺点存在毫秒级延迟同步缓存更新适合最终一致性场景强一致性方案加锁双写适用场景对一致性要求极高如金融交易库存扣减可接受性能损耗流程写操作加分布式锁更新更新释放锁读操作加分布式锁查未命中则查并回写释放锁原理通过锁保证读写互斥避免并发导致的不一致缺点锁会降低并发性能读写均需等待锁仅适合低并发高一致性场景三必加兜底缓存过期时间无论采用哪种方案都需为缓存设置合理的过期时间如分钟即使出现偶发不一致如删除缓存失败延迟时间不足缓存过期后会被自动淘汰后续请求从加载最新数据保证最终一致性缓存雪崩击穿穿透是什么怎么解决穿透缓存穿透是指请求查询的数据在缓存和数据库中都不存在导致每次请求都会穿透缓存直接访问数据库缓存空值当数据库返回空结果时也将空值写入缓存并设置较短的过期时间如分钟布隆过滤器将所有存在的哈希到一个位数组中请求先经过布隆过滤器判断是否可能存在击穿某个热点突然过期而此时恰好有大量请求查询该这些请求会同时绕过缓存集中访问数据库互斥锁分布式锁当缓存失效时只有第一个请求能获取锁去数据库查询其他请求等待并重试用这个命令或者分布式锁对热点不设置过期时间通过后台任务定时更新缓存雪崩缓存中大量在同一时间段内集中过期或缓存服务器集群整体故障导致海量请求无法从缓存获取数据全部涌向数据库过期时间随机化在设置过期时间时增加一个随机值如分钟分钟避免大量同时过期缓存集群化使用或主从哨兵模式避免单点故障熔断降级处理当缓存失效或数据库压力过大时通过熔断机制直接返回默认数据或错误提示保护后端限流处理对数据库入口做限流保护防止瞬时请求量过大多级缓存结合本地缓存分布式缓存减少对单一缓存层的依赖布隆过滤器原理介绍一下布隆过滤器布隆过滤器是一种高效的空间优化型数据结构用于判断一个元素是否可能存在或一定不存在原理初始化一个长度为的数组全定义个哈希函数每插入一个元素计算它的个哈希值将对应位置设为判断是否存在检查所有哈希位置是否都是如果有一定不存在如果全是可能存在存在误判应用场景缓存穿透防护布隆过滤器黑名单快速判断垃圾邮件过滤爬虫去重等如何设计秒杀场景处理高并发以及超卖现象用户前端验证码排队静态资源限流应用服务接口限流熔断消息队列削峰消费者处理订单原子扣减库存库存预热原始库存最终扣减库存带条件更新按钮置灰与防重复提交用户点击秒杀按钮后立即置灰禁止重复点击通过前端防抖如秒内只允许次请求减少重复提交验证码排队机制秒杀开始前要求用户输入图形验证码或完成滑块验证过滤机器人脚本将用户放入前端排队队列如显示排队中第位分散请求发送时间静态资源化秒杀页面的图片等静态资源全部部署到避免请求穿透到应用服务器限流通过模块设置每秒最大请求数如限制单每秒次请求超过阈值直接返回系统繁忙黑名单拦截通过网关拦截频繁请求的恶意如分钟内请求超过次加入临时黑名单接口限流在应用服务中通过实现分布式限流如滑动窗口算法限制秒杀接口的全局如每秒万次超过则返回降级提示服务熔断降级使用等组件当服务响应时间超过阈值或错误率过高时自动熔断返回稍候再试等友好提示避免服务雪崩通过消息队列如将同步请求转为异步处理将瞬时高流量削平为匀速流量防超卖库存操作的原子性与一致性超卖的本质是库存扣减非原子化如并发查库存扣库存导致多扣需通过预扣减原子操作多层校验保证库存安全库存预热预存库存快速判断秒杀开始前将商品库存从加载到如后续库存判断和扣减优先操作内存操作支持高并发预热时机秒杀活动开始前分钟通过定时任务从同步库存到优势避免秒杀开始时大量请求查询减轻数据库压力原子扣减拦截超量请求核心防超卖利用的命令原子操作预扣库存确保同一时间只有一个请求能成功扣减流程用户请求进入后先执行若返回值说明库存充足允许继续下单若返回值直接返回已抢完原理是单线程原子操作即使数万并发请求同时执行也能保证库存扣减的准确性避免超卖最终校验保证数据一致性兜底机制扣减成功后需异步同步到通过消息队列消费此时需再次校验库存避免与不一致导致的超卖层面扣减库存时用带条件的更新语句利用行锁保证原子性仅当库存时才扣减返回影响行数成功失败若更新影响行数为说明实际库存已不足需回滚库存并取消用户订单库存一致性维护定时对账启动定时任务如每秒一次对比库存与库存若存在差异如因网络问题未扣减以为准修正最终库存锁定订单创建后设置分钟支付超时未支付则释放库存同时加回避免库存长期占用假如里面有亿个其中有个是以某个固定的已知的前缀开头的如何将它们全部找出来首先禁止使用命令虽然可以返回所有匹配前缀的阻塞单线程执行期间无法处理其他命令内存消耗激增可能导致是提供的渐进式遍历命令通过游标迭代的方式分批返回匹配的每次扫描只处理部分数据不会阻塞服务适合处理大规模场景语法游标初始为每次扫描后返回新游标直到游标为表示遍历完成匹配模式如匹配前缀为的指定每次扫描的预估数量非精确值会根据内部数据结构调整里有数据中只存的数据如何保证中的数据都是热点数据首先需通过和配置限制缓存的数据量或内存占用假设每条数据平均万条约可据此设置推荐比更精准可能误淘汰曾经热近期没访问但未来可能热的数据基于访问频率更贴合热点定义避免一次性将的万数据全量加载到而是按需加载仅当数据被访问时才加载确保进入的数据都是被访问过的基础配置开启和自动淘汰冷数据业务埋点统计数据访问频率仅将高频数据写入减少冷数据进入定时同步每分钟筛选万热点数据同步到并删除冷数据严格控制数量优化防护用模式更新缓存布隆过滤器防穿透核心热点数据永不过期',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-01 15:32:31',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://gukeyang.github.io" title="博客"><img class="back-menu-item-icon" src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">北川的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/./img/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/./img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Docker/" style="font-size: 1.05rem;">Docker<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">JVM调优<sup>1</sup></a><a href="/tags/Kafka/" style="font-size: 1.05rem;">Kafka<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/Mybatis/" style="font-size: 1.05rem;">Mybatis<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 1.05rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redis/" style="font-size: 1.05rem;">Redis<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/SpringMVC/" style="font-size: 1.05rem;">SpringMVC<sup>1</sup></a><a href="/tags/Springboot/" style="font-size: 1.05rem;">Springboot<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>1</sup></a><a href="/tags/nacos/" style="font-size: 1.05rem;">nacos<sup>1</sup></a><a href="/tags/seata/" style="font-size: 1.05rem;">seata<sup>1</sup></a><a href="/tags/sentinel/" style="font-size: 1.05rem;">sentinel<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 1.05rem;">复习<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>1</sup></a><a href="/tags/%E5%BA%93%E5%AD%98/" style="font-size: 1.05rem;">库存<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E7%94%B5%E5%95%86/" style="font-size: 1.05rem;">电商<sup>1</sup></a><a href="/tags/%E7%A7%92%E6%9D%80/" style="font-size: 1.05rem;">秒杀<sup>1</sup></a><a href="/tags/%E8%AE%A2%E5%8D%95/" style="font-size: 1.05rem;">订单<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96/" style="font-size: 1.05rem;">超卖<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 1.05rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/11/"><span class="card-archive-list-date">十一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">10</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Redis/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Redis</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Redis面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-10-30T04:31:36.000Z" title="发表于 2025-10-30 12:31:36">2025-10-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-11-01T07:32:31.987Z" title="更新于 2025-11-01 15:32:31">2025-11-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="leancloud_visitors" id="/posts/adbd2430.html" data-flag-title="Redis面试题"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span class="leancloud-visitors-count" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新乡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新乡</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/adbd2430.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/adbd2430.html" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=cdc92548-a3c3-d014-7322-6a9bc2cd18dd"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://gukeyang.github.io/posts/adbd2430.html"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a><a href="/tags/Redis/" tabindex="-1" itemprop="url">Redis</a><h1 id="CrawlerTitle" itemprop="name headline">Redis面试题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">北川</span><time itemprop="dateCreated datePublished" datetime="2025-10-30T04:31:36.000Z" title="发表于 2025-10-30 12:31:36">2025-10-30</time><time itemprop="dateCreated datePublished" datetime="2025-11-01T07:32:31.987Z" title="更新于 2025-11-01 15:32:31">2025-11-01</time></header><p>Redis 是面试中的高频考点，重点集中在 <strong>数据结构、持久化机制、高可用（主从 &#x2F; 哨兵 &#x2F; 集群）、缓存问题（穿透 &#x2F; 击穿 &#x2F; 雪崩）、性能优化</strong> 等方面。</p>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis（Remote Dictionary Server）是一个开源的<strong>高性能键值对（key-value）数据库</strong>，它将数据存储在内存中，因此具有极高的读写速度，同时也支持数据持久化到磁盘，以防止数据丢失。</p>
<ol>
<li><strong>基于内存存储</strong>：数据主要存于内存，读写速度极快（毫秒级响应），适合高频访问场景。</li>
<li><strong>支持多种数据结构</strong>：不仅支持字符串（String），还包括哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set）、位图（Bitmap）、地理空间（Geospatial）等，灵活满足不同业务需求。</li>
<li><strong>持久化机制</strong>：通过 RDB（快照）和 AOF（日志追加）两种方式将内存数据持久化到磁盘，平衡性能与数据安全性。</li>
<li><strong>高并发与扩展性</strong>：支持主从复制、哨兵模式（Sentinel）和集群（Cluster），可实现高可用和水平扩展，应对海量请求。</li>
<li><strong>丰富的功能</strong>：提供事务、发布订阅、Lua 脚本、过期键自动删除等功能，适合缓存、计数器、消息队列、排行榜等场景。</li>
</ol>
<h2 id="Redis系统架构模型"><a href="#Redis系统架构模型" class="headerlink" title="Redis系统架构模型"></a>Redis系统架构模型</h2><p>Redis采用单线程 + 多路复用 + 内存存储：</p>
<ul>
<li><p>Redis 的<strong>核心读写操作由单个线程处理</strong>（避免多线程上下文切换开销），通过 “串行化” 处理命令保证原子性（无需锁机制）。</p>
</li>
<li><p>基于操作系统的 IO 多路复用机制（如 Linux 的 <code>epoll</code>、Windows 的 <code>IOCP</code>），单线程可同时监听多个客户端连接的 IO 事件（读 &#x2F; 写请求），高效处理并发请求。</p>
</li>
<li><p>所有数据默认存储在内存中，读写速度极快（微秒级响应），远超磁盘数据库。</p>
</li>
</ul>
<h2 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h2><ul>
<li>Redis的大部分操作都是基于内存完成的，并且采用了高效的数据结构，因此Redis瓶颈可能是机器的内存和网络带宽。</li>
<li>Redis采用单线程的话避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销</li>
<li>Redis采用了I&#x2F;O多路复用机制处理大量的客户端Socket请求，IO多路复用机制是指一个线程处理多个IO流，就是我们经常听到select&#x2F;epoll机制。简单来说，在Redis只运行单线程的情况下，该机制允许内核中，同时存在多个监听Socket和已连接Socket。内核会一直监听这些Socket上的连接请求或数据请求。一旦有请求到达，就会交给Redis线程处理，这就实现了一个Redis线程处理多个IO流的效果。</li>
</ul>
<h2 id="Redis的基本数据类型"><a href="#Redis的基本数据类型" class="headerlink" title="Redis的基本数据类型"></a>Redis的基本数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>核心特性</th>
<th>常用命令（示例）</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字符串（String）</strong></td>
<td>存储文本、数字、二进制数据；最大 512MB；支持原子操作和过期时间</td>
<td><code>SET</code>&#x2F;<code>GET</code>、<code>INCR</code>&#x2F;<code>DECR</code>、<code>APPEND</code>、<code>EXPIRE</code></td>
<td>缓存简单数据（用户信息）、计数器（阅读量）、分布式锁</td>
</tr>
<tr>
<td><strong>哈希（Hash）</strong></td>
<td>键值对集合，适合存储对象；可单独操作字段；节省内存</td>
<td><code>HSET</code>&#x2F;<code>HGET</code>、<code>HGETALL</code>、<code>HDEL</code>、<code>HLEN</code></td>
<td>存储对象信息（用户资料、商品属性）</td>
</tr>
<tr>
<td><strong>列表（List）</strong></td>
<td>有序、可重复元素；双向操作；底层为链表 &#x2F; 压缩列表</td>
<td><code>LPUSH</code>&#x2F;<code>RPUSH</code>、<code>LPOP</code>&#x2F;<code>RPOP</code>、<code>LRANGE</code></td>
<td>消息队列、最新列表（朋友圈动态）、栈 &#x2F; 队列实现</td>
</tr>
<tr>
<td><strong>集合（Set）</strong></td>
<td>无序、不可重复元素；支持交集 &#x2F; 并集 &#x2F; 差集；查找效率 O (1)</td>
<td><code>SADD</code>、<code>SMEMBERS</code>、<code>SISMEMBER</code>、<code>SINTER</code>（交集）、<code>SUNION</code>（并集）</td>
<td>标签系统（文章标签）、好友关系（共同好友）、去重操作</td>
</tr>
<tr>
<td><strong>有序集合（Sorted Set）</strong></td>
<td>元素关联分数（score），按分数排序；支持范围查询；底层为跳表</td>
<td><code>ZADD</code>、<code>ZRANGE</code>（升序）、<code>ZREVRANGE</code>（降序）、<code>ZSCORE</code>、<code>ZINCRBY</code></td>
<td>排行榜（游戏积分、销量排名）、优先级队列、范围统计（分数区间用户）</td>
</tr>
<tr>
<td><strong>位图（Bitmap）</strong></td>
<td>二进制位操作（String 扩展）；适合存储布尔值序列；节省空间</td>
<td><code>SETBIT</code>（设定位）、<code>GETBIT</code>（获取位）、<code>BITCOUNT</code>（统计 1 的个数）</td>
<td>用户签到、在线状态、权限标记</td>
</tr>
<tr>
<td><strong>地理空间（Geospatial）</strong></td>
<td>存储经纬度；支持距离计算、范围查询</td>
<td><code>GEOADD</code>（添加坐标）、<code>GEODIST</code>（计算距离）、<code>GEORADIUS</code>（查找范围内元素）</td>
<td>附近的人、LBS 服务（附近门店）</td>
</tr>
<tr>
<td><strong>流（Stream）</strong></td>
<td>专为消息队列设计；支持持久化、消费确认、分组消费</td>
<td><code>XADD</code>（添加消息）、<code>XREAD</code>（读取消息）、<code>XGROUP</code>（创建消费组）</td>
<td>高可靠消息队列（日志收集、异步任务）</td>
</tr>
<tr>
<td><strong>HyperLogLog</strong></td>
<td>近似统计基数（不重复元素数）；占用内存极小（约 12KB）；误差率低</td>
<td><code>PFADD</code>（添加元素）、<code>PFCOUNT</code>（统计基数）、<code>PFMERGE</code>（合并多个 HyperLogLog）</td>
<td>海量数据去重统计（UV 计数、访问 IP 去重）</td>
</tr>
</tbody></table>
<h2 id="Redis各数据类型有哪些应用场景？"><a href="#Redis各数据类型有哪些应用场景？" class="headerlink" title="Redis各数据类型有哪些应用场景？"></a>Redis各数据类型有哪些应用场景？</h2><p>Redis在互联网产品中使用的场景实在是太多太多，这里分别对Redis几种数据类型做了整理：</p>
<ul>
<li>String：缓存、限流、分布式锁、计数器、分布式Session等。</li>
<li>Hash：用户信息、用户主页访问量、组合查询等。</li>
<li>List：简单队列、关注列表时间轴。</li>
<li>Set：赞、踩、标签等。</li>
<li>ZSet：排行榜、好友关系链表。</li>
</ul>
<h2 id="Redis-中-set和zset区别是什么？"><a href="#Redis-中-set和zset区别是什么？" class="headerlink" title="Redis 中 set和zset区别是什么？"></a>Redis 中 set和zset区别是什么？</h2><table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>Set（集合）</strong></th>
<th><strong>ZSet（有序集合）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>有序性</strong></td>
<td>无序。元素存储和返回的顺序与插入顺序无关（底层哈希表实现）。</td>
<td>有序。每个元素关联一个<strong>分数（score）</strong>，元素按分数升序排列（底层跳表 + 哈希表实现）。</td>
</tr>
<tr>
<td><strong>元素唯一性</strong></td>
<td>元素不可重复（重复插入会被忽略）。</td>
<td>元素不可重复（重复插入会覆盖原元素的分数），但分数可以重复。</td>
</tr>
<tr>
<td><strong>核心特性</strong></td>
<td>侧重<strong>去重</strong>和<strong>集合运算</strong>（交集、并集、差集）。</td>
<td>侧重<strong>排序</strong>和<strong>范围查询</strong>（按分数筛选、取前 N 名等）。</td>
</tr>
<tr>
<td><strong>常用命令</strong></td>
<td>- 添加：<code>SADD key member</code>- 查所有：<code>SMEMBERS key</code>- 交集：<code>SINTER key1 key2</code>- 判断存在：<code>SISMEMBER key member</code></td>
<td>- 添加：<code>ZADD key score member</code>（需指定分数）- 升序查：<code>ZRANGE key start end</code>- 降序查：<code>ZREVRANGE key start end</code>- 查分数：<code>ZSCORE key member</code>- 分数自增：<code>ZINCRBY key increment member</code></td>
</tr>
<tr>
<td><strong>查询效率</strong></td>
<td>单元素查询 O (1)，但无法按顺序或范围批量查询（只能全量获取）。</td>
<td>支持按分数范围查询（如 <code>ZRANGEBYSCORE</code>），时间复杂度 O (logN + M)（N 为总数，M 为结果数），效率高。</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>仅存储元素本身，内存占用较低。</td>
<td>需额外存储每个元素的分数，内存占用略高于 Set。</td>
</tr>
</tbody></table>
<h2 id="Redis哪些地方使用了多线程"><a href="#Redis哪些地方使用了多线程" class="headerlink" title="Redis哪些地方使用了多线程?"></a>Redis哪些地方使用了多线程?</h2><p><strong>网络 IO 处理（Redis 6.0+）</strong>：引入了多线程处理网络 IO，主要解决 “网络读写瓶颈” 问题。</p>
<p>主线程负责命令的解析、执行和结果处理，而<strong>网络数据的读取（read）和写入（write）</strong> 由专门的 IO 线程处理。</p>
<p><strong>异步删除大键</strong>：</p>
<p>当删除超大键（如包含百万级元素的哈希表、列表）时，直接删除会阻塞主线程。Redis 引入了<strong>后台线程（bio 线程）</strong> 异步处理删除操作：</p>
<ul>
<li>使用 <code>unlink</code> 命令替代 <code>del</code> 时，Redis 会将删除操作丢给后台线程，主线程无需等待，继续处理其他命令。</li>
<li>类似的，<code>flushdb async</code>、<code>flushall async</code> 等异步清空命令也依赖后台线程执行。</li>
</ul>
<p><strong>AOF 日志刷盘（fsync 操作）</strong>：</p>
<p>AOF（Append Only File）持久化中，数据先写入内存缓冲区，再定期刷到磁盘。其中 <strong><code>fsync</code> 系统调用（将缓冲区数据强制写入磁盘）</strong> 可能阻塞主线程，因此 Redis 提供了多线程选项：</p>
<ul>
<li>配置 <code>appendfsync everysec</code> 时，Redis 会使用后台线程每隔 1 秒执行一次 <code>fsync</code>，避免主线程阻塞。</li>
</ul>
<p><strong>RDB 持久化（部分阶段）</strong>：</p>
<p>RDB 持久化通过 <code>fork</code> 子进程生成快照，子进程负责写入数据到磁盘，不影响主线程。虽然 <code>fork</code> 本身是单线程操作（主线程短暂阻塞），但子进程的 IO 写入过程本质上是独立的 “线程 &#x2F; 进程” 行为，可视为多进程 &#x2F; 线程协作的场景。</p>
<h2 id="Redis怎么实现的io多路复用？"><a href="#Redis怎么实现的io多路复用？" class="headerlink" title="Redis怎么实现的io多路复用？"></a>Redis怎么实现的io多路复用？</h2><p>这里的“多路”指的其实是多个网络连接客户端，“复用”指的是同一个线程。I&#x2F;O多路复用其实是使用一个线程来检查多个Socket的就绪状态，在单个线程中通过记录跟踪每一个socket的状态来管理处理多个I&#x2F;O流。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720433058791-94f03cb5-e89c-45ed-ba34-88a0dac99d98.png" alt="img"></p>
<h2 id="如何实现redis-原子性？"><a href="#如何实现redis-原子性？" class="headerlink" title="如何实现redis 原子性？"></a>如何实现redis 原子性？</h2><p>Redis 原子性的核心是<strong>单线程串行执行</strong>，在此基础上通过事务、Lua 脚本扩展多命令原子性，并用原生命令覆盖高频场景，兼顾效率与一致性。</p>
<h3 id="1-单线程执行模型：单个命令的天然原子性"><a href="#1-单线程执行模型：单个命令的天然原子性" class="headerlink" title="1. 单线程执行模型：单个命令的天然原子性"></a>1. 单线程执行模型：单个命令的天然原子性</h3><p>Redis 的核心命令执行是单线程的（网络 IO 等辅助操作可多线程，但命令逻辑串行）。这意味着：</p>
<ul>
<li>同一时间只会执行一个命令，不会有 “并行修改” 冲突；</li>
<li>单个命令从读取、处理到结果写入的全过程，不会被其他命令打断。因此，所有单个 Redis 命令本身就是原子操作（比如INCR、HSET等）。</li>
</ul>
<h3 id="2-事务（MULTI-EXEC）：多命令的原子性打包"><a href="#2-事务（MULTI-EXEC）：多命令的原子性打包" class="headerlink" title="2. 事务（MULTI&#x2F;EXEC）：多命令的原子性打包"></a>2. 事务（MULTI&#x2F;EXEC）：多命令的原子性打包</h3><p>当需要多个命令作为整体执行时，用事务机制：</p>
<ul>
<li>流程：<code>MULTI</code> 开启事务 → 后续命令入队（不执行）→ <code>EXEC</code> 触发所有命令按顺序原子执行。</li>
<li>原子性保证：<code>EXEC</code> 执行期间，单线程会串行处理队列中所有命令，中间不会插入其他客户端命令；若入队时有语法错误，事务会整体取消。</li>
<li>注意：Redis 事务不支持回滚（执行中某命令失败，其他仍会继续），主要保证 “要么全执行，要么全不执行”。</li>
</ul>
<h3 id="3-Lua-脚本：复杂逻辑的原子性"><a href="#3-Lua-脚本：复杂逻辑的原子性" class="headerlink" title="3. Lua 脚本：复杂逻辑的原子性"></a>3. Lua 脚本：复杂逻辑的原子性</h3><p>对于需要依赖中间结果的复杂逻辑（如带条件判断），用 Lua 脚本：</p>
<ul>
<li>原理：整个脚本会被 Redis 作为 “单个单元” 执行，执行期间不会被任何其他命令打断。</li>
<li>优势：支持 <code>if-else</code> 等逻辑，比事务更灵活；一次脚本调用完成多命令，减少网络开销。</li>
</ul>
<h3 id="4-原生原子命令：高频场景的简化支持"><a href="#4-原生原子命令：高频场景的简化支持" class="headerlink" title="4. 原生原子命令：高频场景的简化支持"></a>4. 原生原子命令：高频场景的简化支持</h3><p>Redis 针对常见场景设计了原生原子命令，避免用户手动组合命令的风险，比如：</p>
<ul>
<li><code>INCR/DECR</code>：原子性完成 “读 - 改 - 写” 自增；</li>
<li><code>SETNX</code>：仅当 key 不存在时设置值，原子性实现加锁；</li>
<li><code>RPOPLPUSH</code>：原子性转移列表元素。</li>
</ul>
<h2 id="Redis-事务的基本命令有哪些？执行流程？"><a href="#Redis-事务的基本命令有哪些？执行流程？" class="headerlink" title="Redis 事务的基本命令有哪些？执行流程？"></a>Redis 事务的基本命令有哪些？执行流程？</h2><p><strong>核心命令</strong>：<code>MULTI</code>（开启事务）、<code>EXEC</code>（执行事务队列）、<code>DISCARD</code>（放弃事务，清空队列）、<code>WATCH</code>（监视键，实现乐观锁）。</p>
<p><strong>执行流程</strong>：</p>
<ol>
<li>用 <code>MULTI</code> 开启事务，客户端进入 “命令入队模式”；</li>
<li>后续命令不会立即执行，而是被放入事务队列（返回 “QUEUED”）；</li>
<li>执行 <code>EXEC</code> 时，Redis 按顺序原子性执行队列中所有命令；若执行 <code>DISCARD</code>，则清空队列，放弃事务。</li>
</ol>
<h2 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h2><p>为了保证内存中的数据不会丢失，Redis实现列数据了持久化机制，这个机制会把数据存储在磁盘，这样在Redis重启能够恢复数据。</p>
<h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><p>AOF 是<strong>命令日志</strong>，记录所有写操作命令（如 <code>SET</code>、<code>INCR</code> 等），以文本形式追加到文件（默认 <code>appendonly.aof</code>）。恢复时，Redis 会重新执行日志中的所有命令，重建数据。</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h4><ol>
<li><strong>命令追加</strong>：执行写命令后，先将命令追加到内存中的 AOF 缓冲区（避免频繁 IO）。</li>
<li><strong>文件写入</strong>：缓冲区数据定期同步到磁盘 AOF 文件（同步策略可配置）。</li>
<li><strong>文件重写</strong>：AOF 文件会随命令增多而变大，通过 “重写” 机制压缩（合并重复命令，如多次 <code>INCR</code> 合并为最终值的 <code>SET</code>）</li>
</ol>
<h4 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a><strong>关键机制</strong></h4><ul>
<li><strong>同步策略</strong>（通过 <code>appendfsync</code> 配置，平衡安全性和性能）：<ul>
<li><code>always</code>：每个命令执行后立即同步到磁盘（安全性最高，但 IO 开销大，性能差）。</li>
<li><code>everysec</code>：每秒同步一次（默认，最多丢失 1 秒数据，平衡安全与性能）。</li>
<li><code>no</code>：由操作系统决定何时同步（性能最好，但可能丢失大量数据）。</li>
</ul>
</li>
<li><strong>AOF 重写</strong>（解决文件过大问题）：<ul>
<li>触发方式：手动执行 <code>bgrewriteaof</code>；或自动触发（配置 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code>，当文件大小超过阈值且增长比例达标时触发）。</li>
<li>过程：主线程 <code>fork</code> 子进程，子进程遍历内存数据，生成新的 AOF 日志（只保留最终状态的命令），期间新命令会写入 “重写缓冲区”，重写完成后合并到新文件，替换旧文件。</li>
</ul>
</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul>
<li><strong>优点</strong>：<ul>
<li>数据安全性高：可通过 <code>everysec</code> 配置将数据丢失控制在 1 秒内。</li>
<li>日志是文本命令，易理解和修复（如误操作可手动编辑日志删除错误命令）。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>文件体积大（文本命令，无压缩），恢复速度慢（需重新执行所有命令）。</li>
<li>重写时 <code>fork</code> 子进程有开销，且高并发下 <code>everysec</code> 策略可能导致短暂阻塞（同步时若磁盘 IO 慢，主线程会等待）。</li>
</ul>
</li>
</ul>
<h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><p>RDB 是<strong>某一时刻内存数据的二进制快照</strong>（类似 “照片”），将当前内存中所有键值对以压缩的二进制形式写入磁盘（默认文件 <code>dump.rdb</code>）。恢复时，直接加载该文件到内存即可。</p>
<h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><ol>
<li><strong>手动触发</strong><ul>
<li><code>save</code>：主线程直接执行快照，期间会阻塞所有客户端请求（不推荐，可能导致 Redis 卡顿）。</li>
<li><code>bgsave</code>：主线程 <code>fork</code> 一个子进程，由子进程负责写入 RDB 文件，主线程继续处理命令（非阻塞，推荐）。</li>
</ul>
</li>
<li><strong>自动触发</strong>（通过配置文件 <code>redis.conf</code>）<ul>
<li>配置 <code>save m n</code>：表示 “m 秒内有 n 次键修改” 时，自动触发<code>bgsave</code>。</li>
<li>其他场景：主从复制时主节点自动触发；执行 <code>shutdown</code> 命令且未开启 AOF 时，会触发 <code>bgsave</code> 确保数据落地。</li>
</ul>
</li>
</ol>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><strong>优点</strong>：<ul>
<li>文件体积小（二进制压缩），恢复速度快（直接加载到内存，无需解析命令）。</li>
<li><code>bgsave</code> 不阻塞主线程，对性能影响小。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>数据安全性低：快照间隔期间若 Redis 崩溃，会丢失这段时间的数据（如配置 <code>save 300 10</code>，则可能丢失 300 秒内的数据）。</li>
<li><code>bgsave</code> 的 <code>fork</code> 操作有开销：<code>fork</code> 子进程时需复制父进程的内存页表，若内存大，<code>fork</code> 可能短暂阻塞主线程。</li>
</ul>
</li>
</ul>
<h2 id="缓存淘汰和过期删除"><a href="#缓存淘汰和过期删除" class="headerlink" title="缓存淘汰和过期删除"></a>缓存淘汰和过期删除</h2><p>Redis 中的<strong>过期删除</strong>和<strong>缓存淘汰</strong>是两个关联但不同的机制：前者解决 “过期键如何被清理” 的问题，后者解决 “内存不足时如何淘汰键以释放空间” 的问题。两者共同保证了 Redis 高效利用内存并维持数据有效性。</p>
<h3 id="一、过期删除策略（处理已过期的键）"><a href="#一、过期删除策略（处理已过期的键）" class="headerlink" title="一、过期删除策略（处理已过期的键）"></a>一、过期删除策略（处理已过期的键）</h3><p>Redis 允许为键设置过期时间（如 <code>EXPIRE key 10</code> 表示 10 秒后过期），当键过期后，需要通过特定策略将其从内存中删除。Redis 采用 **“惰性删除 + 定期删除” 的混合策略 **，而非 “立即删除”（避免频繁删除对性能的影响）。</p>
<h4 id="1-惰性删除（Lazy-Expiration）"><a href="#1-惰性删除（Lazy-Expiration）" class="headerlink" title="1. 惰性删除（Lazy Expiration）"></a>1. 惰性删除（Lazy Expiration）</h4><ul>
<li><strong>原理</strong>：键过期后不会主动删除，而是在<strong>下次被访问时</strong>才检查是否过期：若过期则删除并返回 <code>nil</code>，否则正常返回值。</li>
<li><strong>优点</strong>：无需额外消耗 CPU 监控过期键，只在必要时处理，对性能影响小。</li>
<li><strong>缺点</strong>：若过期键长期未被访问，会一直占用内存（可能导致内存泄漏）。</li>
</ul>
<h4 id="2-定期删除（Periodic-Expiration）"><a href="#2-定期删除（Periodic-Expiration）" class="headerlink" title="2. 定期删除（Periodic Expiration）"></a>2. 定期删除（Periodic Expiration）</h4><ul>
<li><p>原理</p>
<p>：Redis 每隔一段时间（默认 100ms 左右）会主动扫描部分过期键并删除，具体流程：</p>
<ol>
<li>从过期键字典（记录所有键的过期时间）中随机抽取部分键；</li>
<li>删除其中已过期的键；</li>
<li>若删除比例超过 25%，则重复步骤 1（避免大量过期键堆积），否则结束本轮扫描。</li>
</ol>
</li>
<li><p><strong>优点</strong>：主动清理部分过期键，减少 “惰性删除” 导致的内存浪费。</p>
</li>
<li><p><strong>缺点</strong>：扫描频率和范围需控制（避免长时间阻塞主线程），Redis 通过限制每次扫描的时间（默认不超过 25ms）来平衡性能。</p>
</li>
</ul>
<h3 id="二、缓存淘汰策略（内存不足时淘汰键）"><a href="#二、缓存淘汰策略（内存不足时淘汰键）" class="headerlink" title="二、缓存淘汰策略（内存不足时淘汰键）"></a>二、缓存淘汰策略（内存不足时淘汰键）</h3><p>当 Redis 内存使用达到配置的 <code>maxmemory</code> 阈值时，会触发<strong>缓存淘汰策略</strong>，淘汰部分键以释放内存（即使这些键未过期）。Redis 提供 8 种淘汰策略，可通过 <code>maxmemory-policy</code> 配置，核心分为三大类：</p>
<h4 id="1-只淘汰-“设置了过期时间”-的键（volatile-）"><a href="#1-只淘汰-“设置了过期时间”-的键（volatile-）" class="headerlink" title="1. 只淘汰 “设置了过期时间” 的键（volatile-*）"></a>1. 只淘汰 “设置了过期时间” 的键（volatile-*）</h4><ul>
<li><code>volatile-lru</code>：淘汰<strong>最近最少使用</strong>（LRU，Least Recently Used）的过期键。</li>
<li><code>volatile-lfu</code>：淘汰<strong>最近最不常用</strong>（LFU，Least Frequently Used）的过期键（4.0+，比 LRU 多统计访问频率）。</li>
<li><code>volatile-ttl</code>：淘汰<strong>剩余过期时间最短</strong>的键。</li>
<li><code>volatile-random</code>：随机淘汰过期键。</li>
</ul>
<h4 id="2-淘汰所有键（包括未设置过期时间的，allkeys-）"><a href="#2-淘汰所有键（包括未设置过期时间的，allkeys-）" class="headerlink" title="2. 淘汰所有键（包括未设置过期时间的，allkeys-*）"></a>2. 淘汰所有键（包括未设置过期时间的，allkeys-*）</h4><ul>
<li><code>allkeys-lru</code>：淘汰所有键中最近最少使用的键。</li>
<li><code>allkeys-lfu</code>：淘汰所有键中最近最不常用的键（4.0+）。</li>
<li><code>allkeys-random</code>：随机淘汰所有键中的键。</li>
</ul>
<h4 id="3-不淘汰键（noeviction）"><a href="#3-不淘汰键（noeviction）" class="headerlink" title="3. 不淘汰键（noeviction）"></a>3. 不淘汰键（noeviction）</h4><ul>
<li><code>noeviction</code>（默认策略）：不淘汰任何键，当内存不足时，拒绝所有新的写操作（返回错误），读操作正常。</li>
</ul>
<h2 id="主从同步中的增量和完全同步怎么实现？"><a href="#主从同步中的增量和完全同步怎么实现？" class="headerlink" title="主从同步中的增量和完全同步怎么实现？"></a>主从同步中的增量和完全同步怎么实现？</h2><h3 id="完全同步"><a href="#完全同步" class="headerlink" title="完全同步"></a>完全同步</h3><p>完全同步发生在以下几种情况：</p>
<ul>
<li>从节点首次连接主节点（无主节点的<code>runid</code>和同步偏移量<code>offset</code>）；</li>
<li>从节点重连时，主节点的<code>runid</code>已变化（如主节点重启）；</li>
<li>从节点的<code>offset</code>不在主节点的复制积压缓冲区范围内。</li>
</ul>
<p><strong>同步流程</strong>：</p>
<ul>
<li><strong>从节点发起请求</strong>：从节点发送<code>PSYNC ? -1</code>命令（<code>?</code>表示未知主节点<code>runid</code>，<code>-1</code>表示无<code>offset</code>）。</li>
<li><strong>主节点生成 RDB</strong>：主节点收到请求后，执行<code>bgsave</code>生成全量数据的 RDB 快照（异步执行，不阻塞主节点处理新命令），同时将生成 RDB 期间的所有写命令记录到<strong>复制缓冲区（replication buffer，每个从节点独立维护）</strong>。</li>
<li><strong>发送 RDB 给从节点</strong>：主节点将 RDB 文件发送给从节点，从节点接收后清空自身原有数据，加载 RDB 文件（此过程会阻塞从节点，无法处理读请求）。</li>
<li><strong>同步缓冲命令</strong>：RDB 发送完成后，主节点将复制缓冲区中记录的 “生成 RDB 期间的写命令” 发送给从节点，从节点执行这些命令，最终与主节点数据完全一致。</li>
</ul>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>增量同步是指主从节点已完成过完全同步，后续因网络短暂中断等原因重连时，主节点仅向从节点发送 “从节点缺失的那部分命令”，而非全量数据，以减少资源消耗。</p>
<ol>
<li><strong>正常同步阶段</strong>：主节点处理写命令时，会将命令同步给从节点，同时更新自身<code>offset</code>，并将命令写入复制积压缓冲区；从节点接收命令后执行，更新自身<code>offset</code>。</li>
<li><strong>网络中断与重连</strong>：<ul>
<li>网络中断后，主节点继续处理命令并写入复制积压缓冲区，从节点暂停同步。</li>
<li>网络恢复后，从节点发送<code>PSYNC &lt;master_runid&gt; &lt;slave_offset&gt;</code>命令（携带记录的主节点<code>runid</code>和自身当前<code>offset</code>）。</li>
</ul>
</li>
<li><strong>增量同步验证</strong>：<ul>
<li>主节点检查<code>runid</code>是否匹配（确认是同一主节点），并判断从节点的<code>offset</code>是否在复制积压缓冲区的范围内（即<code>offset</code> &gt;&#x3D; 缓冲区起始位置）。</li>
<li>若验证通过，主节点从<code>offset</code>开始，将缓冲区中后续的命令发送给从节点，从节点执行后更新<code>offset</code>，完成增量同步。</li>
</ul>
</li>
</ol>
<h2 id="Redis主从和集群可以保证数据一致性吗-？"><a href="#Redis主从和集群可以保证数据一致性吗-？" class="headerlink" title="Redis主从和集群可以保证数据一致性吗 ？"></a>Redis主从和集群可以保证数据一致性吗 ？</h2><p>Redis 的主从架构和集群（Redis Cluster）<strong>不能保证强一致性</strong>，但能在大多数场景下保证<strong>最终一致性</strong>，其数据一致性的保障程度受架构设计、同步机制和配置参数的影响，存在一定的局限性。(AP)</p>
<h3 id="一、主从架构的一致性问题"><a href="#一、主从架构的一致性问题" class="headerlink" title="一、主从架构的一致性问题"></a>一、主从架构的一致性问题</h3><p>主从架构（一主多从）的核心是 “主节点写入、从节点复制”，但同步机制的本质决定了它无法保证强一致性：</p>
<ul>
<li><strong>异步复制的天然缺陷</strong>主节点处理写命令后，会立即返回结果给客户端，<strong>不会等待从节点同步完成</strong>。此时若主节点突然宕机，未同步到从节点的命令会丢失。从节点提升为主节点后，这部分数据会永久缺失，导致数据不一致。</li>
<li><strong>配置优化的局限性</strong>虽然 Redis 提供了一些参数减少数据丢失风险（如<code>min-replicas-to-write</code>、<code>min-replicas-max-lag</code>），要求主节点必须有至少 N 个从节点在<code>max-lag</code>时间内完成同步才允许写入，但这只能降低丢失概率，无法完全避免（如主从网络突然中断时，主节点可能已接受写入但未同步）。</li>
<li><strong>从节点读取的 “滞后性”</strong>从节点默认允许读操作，但由于同步存在延迟（即使毫秒级），客户端可能从从节点读取到 “旧数据”，出现 “读写不一致”。</li>
</ul>
<h3 id="二、Redis-Cluster（集群）的一致性问题"><a href="#二、Redis-Cluster（集群）的一致性问题" class="headerlink" title="二、Redis Cluster（集群）的一致性问题"></a>二、Redis Cluster（集群）的一致性问题</h3><p>Redis Cluster 通过分片（Sharding）将数据分散到多个主节点，每个主节点有从节点作为备份，其一致性问题本质与主从架构类似，且新增了分片间的协调问题：</p>
<ol>
<li><strong>分片内的异步复制</strong>集群中每个分片（主节点 + 从节点）的同步机制与主从架构一致，仍是异步复制。主节点写入后立即返回，未同步的命令在主节点宕机时可能丢失，导致分片内数据不一致。</li>
<li><strong>故障转移的 “数据缺口”</strong>当主节点故障时，从节点通过选举成为新主节点。若从节点未完全同步主节点的最新数据（如同步延迟或网络中断），新主节点的数据会存在 “缺口”，与客户端预期的最新数据不一致。</li>
<li><strong>跨分片操作的一致性</strong>集群中跨分片的命令（如<code>MSET</code>涉及多个 key 分布在不同分片）是<strong>非原子的</strong>，可能部分分片执行成功、部分失败，导致跨分片数据不一致。Redis Cluster 不支持分布式事务，无法保证跨分片操作的原子性。</li>
<li><strong>最终一致性的前提</strong>只有在网络稳定、无节点故障、同步延迟可接受的情况下，集群内各节点的数据才会逐渐趋于一致（最终一致性）。但极端场景（如网络分区、节点频繁故障）可能导致长时间的数据不一致。</li>
</ol>
<h2 id="Redis-哨兵（Sentinel）机制"><a href="#Redis-哨兵（Sentinel）机制" class="headerlink" title="Redis 哨兵（Sentinel）机制"></a>Redis 哨兵（Sentinel）机制</h2><p>Redis 哨兵（Sentinel）机制是 Redis 官方提供的<strong>高可用解决方案</strong>，主要用于监控主从架构中的节点状态，并在主节点故障时自动完成故障转移（Failover），确保服务持续可用。</p>
<h3 id="一、哨兵的核心功能"><a href="#一、哨兵的核心功能" class="headerlink" title="一、哨兵的核心功能"></a>一、哨兵的核心功能</h3><p>哨兵机制通过一组（通常为 3 个及以上）哨兵进程（Sentinel）协同工作，实现以下功能：</p>
<ol>
<li><strong>监控（Monitoring）</strong>：持续检查主节点（master）和从节点（slave）是否正常运行。</li>
<li><strong>自动故障转移（Automatic Failover）</strong>：当主节点故障时，自动将一个从节点升级为新主节点，并让其他从节点切换到新主节点进行复制。</li>
<li><strong>通知（Notification）</strong>：当节点状态变化（如主节点下线、故障转移完成）时，通过 API（如 Redis 的发布订阅机制）通知管理员或客户端。</li>
<li><strong>配置管理（Configuration Provider）</strong>：客户端通过哨兵获取当前主节点的地址，无需硬编码主节点信息（当主节点切换后，客户端可自动获取新主节点地址）。</li>
</ol>
<h3 id="二、哨兵的架构设计"><a href="#二、哨兵的架构设计" class="headerlink" title="二、哨兵的架构设计"></a>二、哨兵的架构设计</h3><p>哨兵机制通常采用 <strong>“多哨兵集群”</strong>（而非单个哨兵），原因是：单个哨兵可能因自身故障误判主节点状态，而多哨兵通过 “共识机制” 可减少误判，提高可靠性。</p>
<p>典型架构如下：</p>
<ul>
<li>1 个主节点 + N 个从节点（主从复制架构）；</li>
<li>M 个哨兵节点（M ≥ 3，且为奇数，便于选举决策）；</li>
<li>哨兵节点之间相互通信，同时也与所有主从节点保持连接。</li>
</ul>
<h3 id="三、哨兵的工作原理（核心流程）"><a href="#三、哨兵的工作原理（核心流程）" class="headerlink" title="三、哨兵的工作原理（核心流程）"></a>三、哨兵的工作原理（核心流程）</h3><p>哨兵的工作过程可分为<strong>监控与状态判断</strong>、<strong>故障转移触发</strong>、<strong>新主节点选举</strong>、<strong>配置更新</strong>四个阶段。</p>
<h4 id="1-监控与状态判断（节点健康检测）"><a href="#1-监控与状态判断（节点健康检测）" class="headerlink" title="1. 监控与状态判断（节点健康检测）"></a>1. 监控与状态判断（节点健康检测）</h4><p>哨兵通过定期发送命令与主从节点通信，判断节点是否存活，核心涉及两个状态：</p>
<ul>
<li><strong>主观下线（Subjectively Down, SDOWN）</strong>：单个哨兵向某节点（主或从）发送<code>PING</code>命令，如果在配置的<code>down-after-milliseconds</code>时间内未收到有效响应（如超时、错误回复），则该哨兵认为此节点 “主观下线”（仅自身判断，可能存在误判）。</li>
<li><strong>客观下线（Objectively Down, ODOWN）</strong>：仅针对主节点。当一个哨兵判断主节点 “主观下线” 后，会向其他哨兵发送<code>is-master-down-by-addr</code>命令，询问它们是否也认为该主节点下线。如果<strong>超过<code>quorum</code>（配置的最小哨兵数量）个哨兵</strong>均认为主节点 “主观下线”，则该主节点被标记为 “客观下线”（达成共识，确认故障）。</li>
</ul>
<h4 id="2-故障转移触发（当主节点-“客观下线”-后）"><a href="#2-故障转移触发（当主节点-“客观下线”-后）" class="headerlink" title="2. 故障转移触发（当主节点 “客观下线” 后）"></a>2. 故障转移触发（当主节点 “客观下线” 后）</h4><p>主节点被标记为 “客观下线” 后，哨兵集群会启动<strong>故障转移流程</strong>，核心是先选举一个 “哨兵领导者”（Leader Sentinel），由它负责执行后续的故障转移操作（避免多个哨兵同时操作导致混乱）。</p>
<ul>
<li><p>哨兵领导者选举</p>
<p>：</p>
<p>采用类似 Raft 算法的选举机制：</p>
<ol>
<li>每个哨兵向其他哨兵发送<code>vote-for-leader</code>命令，请求将自己选为领导者；</li>
<li>每个哨兵在一轮选举中只能投票给一个候选者；</li>
<li>若某哨兵获得<strong>超过半数（<code>(M/2)+1</code>，M 为哨兵总数）</strong> 的选票，则成为领导者；</li>
<li>若一轮选举未产生领导者，等待一段时间后重新选举，直到选出领导者。</li>
</ol>
</li>
</ul>
<h4 id="3-新主节点选举（从从节点中选一个升级为主节点）"><a href="#3-新主节点选举（从从节点中选一个升级为主节点）" class="headerlink" title="3. 新主节点选举（从从节点中选一个升级为主节点）"></a>3. 新主节点选举（从从节点中选一个升级为主节点）</h4><p>哨兵领导者需从原主节点的所有从节点中，选择一个 “最优” 的从节点升级为新主节点，选择标准如下（优先级从高到低）：</p>
<ol>
<li><strong>排除不健康的从节点</strong>：过滤掉 “主观下线”、连接断开时间过长（超过<code>down-after-milliseconds * 10</code>）的从节点。</li>
<li><strong>优先级最高的从节点</strong>：通过<code>replica-priority</code>配置（默认 100，值越小优先级越高），优先选择优先级高的。</li>
<li><strong>复制进度最完整的从节点</strong>：选择与原主节点的复制偏移量（<code>offset</code>）最接近的从节点（即数据最新的）。</li>
<li><strong>运行时间最久的从节点</strong>：若前两项相同，选择<code>runid</code>（节点唯一标识）最小的（启动时间最早）。</li>
</ol>
<h4 id="4-故障转移执行（更新拓扑结构）"><a href="#4-故障转移执行（更新拓扑结构）" class="headerlink" title="4. 故障转移执行（更新拓扑结构）"></a>4. 故障转移执行（更新拓扑结构）</h4><p>选定新主节点后，哨兵领导者执行以下操作，完成故障转移：</p>
<ol>
<li>向新主节点发送<code>slaveof no one</code>命令，使其停止作为从节点，升级为主节点。</li>
<li>向其他所有从节点发送<code>slaveof &lt;新主节点IP&gt; &lt;新主节点端口&gt;</code>命令，让它们切换到新主节点进行复制。</li>
<li>更新哨兵集群的配置信息（记录新主节点的地址、从节点列表等），并通过发布订阅机制（<code>__sentinel__:hello</code>频道）同步给所有哨兵。</li>
<li>通知客户端（通过客户端订阅的哨兵频道）新主节点的地址，客户端后续将请求发送到新主节点。</li>
</ol>
<h4 id="5-原主节点恢复后的处理"><a href="#5-原主节点恢复后的处理" class="headerlink" title="5. 原主节点恢复后的处理"></a>5. 原主节点恢复后的处理</h4><p>若原主节点（故障节点）恢复上线，哨兵会将其自动转为新主节点的从节点，避免其再次成为主节点导致冲突。</p>
<h2 id="Redis集群的模式了解吗-优缺点了解吗"><a href="#Redis集群的模式了解吗-优缺点了解吗" class="headerlink" title="Redis集群的模式了解吗 优缺点了解吗"></a>Redis集群的模式了解吗 优缺点了解吗</h2><p>Redis 集群（Redis Cluster）是 Redis 官方提供的<strong>分布式解决方案</strong>，主要用于解决单机 Redis 的容量瓶颈（内存、QPS 上限）和高可用问题，支持数据分片、自动故障转移和水平扩展。其核心设计围绕 “分片存储” 和 “去中心化高可用” 展开，以下是其模式细节及优缺点分析：</p>
<h3 id="一、Redis-集群的核心模式（设计特点）"><a href="#一、Redis-集群的核心模式（设计特点）" class="headerlink" title="一、Redis 集群的核心模式（设计特点）"></a>一、Redis 集群的核心模式（设计特点）</h3><p>Redis 集群的核心目标是实现<strong>大规模数据的分布式存储</strong>和<strong>自动化的高可用保障</strong>，其关键机制包括：</p>
<h4 id="1-数据分片：基于哈希槽（Hash-Slot）"><a href="#1-数据分片：基于哈希槽（Hash-Slot）" class="headerlink" title="1. 数据分片：基于哈希槽（Hash Slot）"></a>1. 数据分片：基于哈希槽（Hash Slot）</h4><p>Redis 集群将数据分散存储在多个节点上，核心通过 “哈希槽” 实现分片：</p>
<ul>
<li>总共有 <strong>16384 个哈希槽</strong>（固定值，范围 0-16383），每个槽对应一部分数据。</li>
<li>集群中的每个主节点（Master）负责一部分哈希槽（例如，3 个主节点可能分别负责 5000、5000、6384 个槽）。</li>
<li>数据分配规则：对键（key）计算哈希值 <code>CRC16(key) % 16384</code>，得到对应的哈希槽，该键就存储在负责此槽的主节点上。</li>
</ul>
<p>这种设计的优势是：</p>
<ul>
<li>分片规则简单，客户端可直接计算键所在的节点，无需通过中心节点转发；</li>
<li>支持动态调整槽分配（例如，新增节点时可将部分槽从旧节点迁移到新节点，实现水平扩展）。</li>
</ul>
<h4 id="2-主从复制与故障转移"><a href="#2-主从复制与故障转移" class="headerlink" title="2. 主从复制与故障转移"></a>2. 主从复制与故障转移</h4><p>为保证高可用，集群中每个主节点会配置 1 个或多个从节点（Slave），形成 “一主多从” 的分片单元：</p>
<ul>
<li>从节点复制主节点的数据，作为备份；</li>
<li>当主节点故障（如宕机、网络中断）时，集群会自动从其从节点中选举一个升级为新主节点，接管原主节点的哈希槽，整个过程无需人工干预（类似哨兵机制，但集成在集群内部）。</li>
</ul>
<h4 id="3-去中心化设计"><a href="#3-去中心化设计" class="headerlink" title="3. 去中心化设计"></a>3. 去中心化设计</h4><p>集群中没有 “中心节点”，所有节点（主 + 从）通过<strong>Gossip 协议</strong>相互通信：</p>
<ul>
<li>节点定期交换状态信息（如自身健康状态、负责的槽、主从关系等），维护整个集群的元数据（如哪个节点负责哪些槽）；</li>
<li>客户端连接集群时，只需与任意一个节点通信，即可获取全量的槽分配信息，进而直接与目标节点交互。</li>
</ul>
<h4 id="4-容错与可用性保障"><a href="#4-容错与可用性保障" class="headerlink" title="4. 容错与可用性保障"></a>4. 容错与可用性保障</h4><ul>
<li>集群通过 “投票机制” 判断节点是否故障：当超过半数的主节点认为某个节点不可达时，标记该节点为 “故障”；</li>
<li>若主节点故障且无可用从节点，集群会进入 “部分可用” 状态（仅故障节点负责的槽不可用，其他槽正常服务）；</li>
<li>支持配置<code>cluster-require-full-coverage</code>（默认 yes）：若设为 no，即使部分槽不可用，集群仍允许其他槽的读写。</li>
</ul>
<h3 id="二、Redis-集群的优点"><a href="#二、Redis-集群的优点" class="headerlink" title="二、Redis 集群的优点"></a>二、Redis 集群的优点</h3><ol>
<li><strong>水平扩展能力强</strong>支持动态增加节点（主从），通过迁移哈希槽实现数据负载均衡，理论上可无限扩展（受限于实际部署成本），解决了单机 Redis 的内存和 QPS 上限问题。</li>
<li><strong>高可用内置化</strong>集成了主从复制和自动故障转移功能（无需额外部署哨兵），主节点故障后自动切换从节点为新主，减少服务中断时间。</li>
<li><strong>去中心化，无单点瓶颈</strong>节点间通过 Gossip 协议平等通信，无中心节点，避免了中心节点的性能或故障瓶颈。</li>
<li><strong>分片规则高效</strong>基于哈希槽的分片逻辑简单，客户端可直接定位键所在节点，减少转发开销；槽迁移过程中数据可正常访问（通过 “ASK” 重定向机制）。</li>
<li><strong>适合大规模数据场景</strong>相比主从架构（全量数据复制），集群通过分片将数据分散存储，每个节点仅存储部分数据，降低了单节点的存储压力。</li>
</ol>
<h3 id="三、Redis-集群的缺点"><a href="#三、Redis-集群的缺点" class="headerlink" title="三、Redis 集群的缺点"></a>三、Redis 集群的缺点</h3><ol>
<li><strong>数据一致性无法保证（异步复制缺陷）</strong>主节点向从节点的复制是异步的（主节点写入后立即返回客户端，不等待从节点同步），若主节点故障，未同步到从节点的数据会丢失，只能保证最终一致性，不适合强一致性场景。</li>
<li><strong>不支持跨槽的复杂命令</strong>涉及多个键的命令（如<code>MGET key1 key2</code>）若这些键分布在不同哈希槽，集群会直接返回错误（<code>CROSSSLOT Keys in request don&#39;t hash to the same slot</code>）。需通过客户端手动将键 “哈希标签”（如<code>&#123;user:1&#125;:name</code>和<code>&#123;user:1&#125;:age</code>强制分配到同一槽），增加了开发复杂度。</li>
<li><strong>运维复杂度高</strong><ul>
<li>节点扩容 &#x2F; 缩容时需手动迁移哈希槽（或依赖工具），过程中需确保数据一致性；</li>
<li>集群元数据（槽分配、主从关系）维护复杂，故障排查难度高于主从架构；</li>
<li>对网络稳定性要求高：Gossip 协议的信息同步依赖网络，网络分区可能导致集群状态判断混乱。</li>
</ul>
</li>
<li><strong>内存和网络开销较大</strong><ul>
<li>每个节点需存储全量的集群元数据（槽分配、节点列表等），节点越多，元数据开销越大；</li>
<li>Gossip 协议的定期信息交换会消耗额外网络带宽（尤其是节点数量较多时）。</li>
</ul>
</li>
<li><strong>兼容性限制</strong>部分 Redis 功能在集群模式下受限：<ul>
<li>不支持事务（<code>MULTI/EXEC</code>）跨多个节点；</li>
<li>不支持<code>KEYS</code>、<code>FLUSHALL</code>等全局命令（需指定节点执行）；</li>
<li>对 Lua 脚本的支持有限（脚本中涉及的键必须在同一槽）。</li>
</ul>
</li>
</ol>
<h3 id="四、适用场景与总结"><a href="#四、适用场景与总结" class="headerlink" title="四、适用场景与总结"></a>四、适用场景与总结</h3><ul>
<li><strong>适用场景</strong>：需要存储大规模数据（超过单机内存）、要求高可用性（自动故障转移）、可接受最终一致性的场景（如电商缓存、用户会话存储、分布式计数器）。</li>
<li><strong>不适用场景</strong>：强一致性需求（如金融交易）、依赖大量跨键命令（如复杂的多键事务）、小规模数据且追求简单运维的场景（此时主从 + 哨兵更合适）。</li>
</ul>
<h2 id="场景题-重点"><a href="#场景题-重点" class="headerlink" title="场景题(重点)"></a>场景题(重点)</h2><h3 id="为什么使用redis"><a href="#为什么使用redis" class="headerlink" title="为什么使用redis?"></a>为什么使用redis?</h3><p>主要是因为 <strong>Redis 具备「高性能」和「高并发」两种特性</strong>。</p>
<p><strong>1、Redis 具备高性能</strong></p>
<p>假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。</p>
<p>如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和MySQL 双写一致性的问题。</p>
<p><strong>2、 Redis 具备高并发</strong></p>
<p>单台设备的 Redis 的 QPS(Query Per Second，每秒钟处理完请求的次数)是 MySQL的 10倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MVSQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<h3 id="为什么redis比mysql要快"><a href="#为什么redis比mysql要快" class="headerlink" title="为什么redis比mysql要快?"></a>为什么redis比mysql要快?</h3><p>内存存储:Redis 是基于内存存储的 NoSQL 数据库，而 MySQL 是基于磁盘存储的关系型数据库。由于内存存储速度快，Redis 能够更快地读取和写入数据，而无需像 MySQL 那样频繁进行磁盘 V0 操作。</p>
<p>简单数据结构:Redis 是基于键值对存储数据的，支持简单的数据结构(字符串、哈希、列表、集合有序集合)。相比之下，MSQL需要定义表结构、索引等复杂的关系型数据结构，因此在某些场景下Redis 的数据操作更为简单高效，比如 Redis 用哈希表查询，只需要O1 时间复杂度，而MvSOL引擎的底层实现是B+Tree，时间复杂度是O(logn)</p>
<p>线程模型:Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</p>
<h3 id="本地缓存和Redis缓存的区别"><a href="#本地缓存和Redis缓存的区别" class="headerlink" title="本地缓存和Redis缓存的区别?"></a>本地缓存和Redis缓存的区别?</h3><ul>
<li>本地缓存的核心优势是<strong>极致性能（无网络开销）</strong> 和<strong>部署简单</strong>，但局限于单机、无法共享、容量有限；</li>
<li>Redis 缓存的核心优势是<strong>分布式共享能力</strong>和<strong>可扩展性</strong>，但存在网络延迟和额外的运维成本。</li>
</ul>
<h3 id="redis应用场景是什么"><a href="#redis应用场景是什么" class="headerlink" title="redis应用场景是什么?"></a>redis应用场景是什么?</h3><p><strong>热点数据缓存</strong>:电商商品详情、用户基本信息、新闻列表、APP 首页推荐数据。</p>
<p><strong>分布式计数器</strong>:基于 Redis 的<code>incr</code>&#x2F;<code>decr</code>等原子命令，实现跨服务、高并发的计数功能，无需担心并发竞争问题。文章阅读量、视频播放量、商品点赞数、秒杀活动库存计数、接口调用次数统计。</p>
<p><strong>分布式会话存储</strong>:在分布式系统中（多台应用服务器），用户 Session 无法通过本地内存共享，Redis 可作为集中式会话存储，实现跨服务器的 Session 同步。Web 网站登录状态、APP 用户登录令牌（如 Token）存储。</p>
<p><strong>有序排行榜</strong>:用 Redis 的<code>ZSet</code>（有序集合）数据结构，天然支持按 “分数” 排序，可高效实现实时排行榜功能。游戏玩家积分排名、直播平台礼物榜、电商商品销量榜、社区话题热度榜</p>
<p><strong>简单消息队列</strong>:通过<code>Pub/Sub</code>（发布订阅）或<code>Stream</code>（Redis 5.0+）功能，实现轻量级消息通知或异步任务处理，适合对消息可靠性要求不极致的场景。用户注册后的短信 &#x2F; 邮件通知、系统日志实时收集、微服务间简单通信。</p>
<p><strong>分布式锁</strong>:基于 Redis 的<code>SET NX PX</code>（仅不存在时设置 + 过期时间）命令的原子性，实现跨服务、跨机器的资源互斥访问，解决分布式环境下的并发冲突。秒杀库存扣减（防止超卖）、定时任务（防止多实例重复执行）、跨服务修改同一条数据（防止脏写）。</p>
<p><strong>Hash（哈希表）</strong>：存储结构化数据，如购物车（<code>cart:user123</code>的 Key 下，<code>商品ID</code>为 Field、<code>数量</code>为 Value），支持单独增删改某个字段，无需操作整个对象。</p>
<h3 id="Redis分布式锁的实现原理"><a href="#Redis分布式锁的实现原理" class="headerlink" title="Redis分布式锁的实现原理?"></a>Redis分布式锁的实现原理?</h3><p><strong>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用</strong></p>
<h4 id="1-加锁：通过SET命令的原子性实现"><a href="#1-加锁：通过SET命令的原子性实现" class="headerlink" title="1. 加锁：通过SET命令的原子性实现"></a>1. 加锁：通过<code>SET</code>命令的原子性实现</h4><p>加锁的核心命令是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET lock_key random_value NX PX 30000</span><br></pre></td></tr></table></figure>

<p>各参数含义：</p>
<ul>
<li><code>lock_key</code>：锁的标识（如 “order:123” 表示订单 123 的锁）；</li>
<li><code>random_value</code>：随机值（如 UUID），用于唯一标识当前加锁的线程 &#x2F; 服务，避免释放锁时误删其他线程的锁；</li>
<li><code>NX</code>：仅当<code>lock_key</code>不存在时才设置成功（保证互斥性，同一时间只有一个线程能加锁）；</li>
<li><code>PX 30000</code>：设置锁的过期时间为 30 秒（防止死锁，即使持有锁的线程崩溃，锁也会自动释放）。</li>
</ul>
<p><strong>加锁逻辑</strong>：</p>
<ul>
<li>若命令返回<code>OK</code>，表示加锁成功；</li>
<li>若返回<code>nil</code>，表示锁已被其他线程持有，加锁失败。</li>
</ul>
<h4 id="2-释放锁：通过-Lua-脚本保证原子性"><a href="#2-释放锁：通过-Lua-脚本保证原子性" class="headerlink" title="2. 释放锁：通过 Lua 脚本保证原子性"></a>2. 释放锁：通过 Lua 脚本保证原子性</h4><p>释放锁时，不能直接用<code>DEL lock_key</code>（可能误删其他线程的锁），需先验证 “当前锁的持有者是否为自己”，再删除。这两步操作需通过<strong>Lua 脚本</strong>原子执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 脚本逻辑：若lock_key的值等于传入的random_value，则删除锁，返回1；否则返回0</span><br><span class="line">if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then</span><br><span class="line">  return redis.call(&#x27;del&#x27;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">  return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行脚本时，传入参数：</p>
<ul>
<li><code>KEYS[1]</code> &#x3D; <code>lock_key</code>（锁标识）；</li>
<li><code>ARGV[1]</code> &#x3D; 加锁时的<code>random_value</code>（当前线程的唯一标识）。</li>
</ul>
<p><strong>释放逻辑</strong>：</p>
<ul>
<li>若锁的 value 与当前线程的<code>random_value</code>一致，说明锁是自己的，执行删除（释放成功）；</li>
<li>若不一致，说明锁已被其他线程持有（可能是自己的锁过期后被别人加锁），不做操作（避免误删）。</li>
</ul>
<h3 id="什么场景下用到分布式锁"><a href="#什么场景下用到分布式锁" class="headerlink" title="什么场景下用到分布式锁?"></a>什么场景下用到分布式锁?</h3><h4 id="1-库存扣减（防止超卖）"><a href="#1-库存扣减（防止超卖）" class="headerlink" title="1. 库存扣减（防止超卖）"></a>1. 库存扣减（防止超卖）</h4><p><strong>场景</strong>：电商秒杀、限量商品抢购等场景中，多个用户同时下单，需扣减同一商品的库存。<strong>问题</strong>：若没有分布式锁，多个服务实例可能同时读取到 “剩余 1 件库存”，并各自执行扣减，导致最终库存为 - 1（超卖）。<strong>分布式锁的作用</strong>：保证同一时间只有一个请求能执行 “查库存 + 扣减库存” 的逻辑，避免并发冲突。</p>
<h4 id="2-定时任务（防止重复执行）"><a href="#2-定时任务（防止重复执行）" class="headerlink" title="2. 定时任务（防止重复执行）"></a>2. 定时任务（防止重复执行）</h4><p><strong>场景</strong>：分布式系统中，多个服务实例部署了相同的定时任务（如每日数据统计、订单超时关闭）。<strong>问题</strong>：若没有锁，所有实例会在同一时间执行任务，导致重复计算（如同一批订单被多次标记为 “超时关闭”），浪费资源且可能引发数据异常。<strong>分布式锁的作用</strong>：任务触发时，多个实例竞争同一把锁，只有抢到锁的实例执行任务，其他实例放弃，保证任务仅执行一次。</p>
<h4 id="3-分布式事务（跨服务数据一致性）"><a href="#3-分布式事务（跨服务数据一致性）" class="headerlink" title="3. 分布式事务（跨服务数据一致性）"></a>3. 分布式事务（跨服务数据一致性）</h4><p><strong>场景</strong>：跨多个服务的事务操作（如 “下单” 需同时扣减库存、扣减余额、生成订单），需保证操作的原子性（要么全成功，要么全回滚）。<strong>问题</strong>：若中间某一步失败（如扣减余额超时），其他服务可能已完成操作，导致数据不一致。<strong>分布式锁的作用</strong>：通过锁约束整个事务流程，确保只有一个进程能处理该业务（如同一订单 ID 的事务），失败时可安全回滚所有操作，避免部分成功的中间状态。</p>
<h4 id="4-共享资源修改（防止脏写）"><a href="#4-共享资源修改（防止脏写）" class="headerlink" title="4. 共享资源修改（防止脏写）"></a>4. 共享资源修改（防止脏写）</h4><p><strong>场景</strong>：多个服务实例同时修改同一条共享数据（如用户的积分、账户余额、配置项）。<strong>问题</strong>：并发修改可能导致 “覆盖写”（如 A 服务读取余额 100 并加 10，B 服务同时读取 100 并加 20，最终结果可能为 110 而非 130）。<strong>分布式锁的作用</strong>：保证 “读取 - 修改 - 写入” 的原子性，同一时间只有一个服务能修改数据，避免脏写。</p>
<h4 id="5-分布式限流（控制全局并发量）"><a href="#5-分布式限流（控制全局并发量）" class="headerlink" title="5. 分布式限流（控制全局并发量）"></a>5. 分布式限流（控制全局并发量）</h4><p><strong>场景</strong>：限制某个接口的全局并发请求数（如同一时间最多允许 100 个请求访问支付接口）。<strong>问题</strong>：单机限流（如每个实例限 20 并发）无法控制全局总量（5 个实例可能同时达到 20，总并发 100，但实际想限制的是全局不超过 100）。<strong>分布式锁的作用</strong>：通过锁的竞争机制控制并发数（如每次请求获取锁，释放锁时计数减 1，超过阈值则拒绝），实现全局统一的限流。</p>
<h4 id="6-分布式-ID-生成（保证-ID-唯一性）"><a href="#6-分布式-ID-生成（保证-ID-唯一性）" class="headerlink" title="6. 分布式 ID 生成（保证 ID 唯一性）"></a>6. 分布式 ID 生成（保证 ID 唯一性）</h4><p><strong>场景</strong>：生成全局唯一 ID（如订单号、流水号），通常基于 “计数器 + 时间戳” 实现。<strong>问题</strong>：多个服务实例同时读取计数器并自增，可能生成重复 ID（如同时读取到计数器值 100，都生成 ID&#x3D;101）。</p>
<h3 id="Redis的大Key问题是什么"><a href="#Redis的大Key问题是什么" class="headerlink" title="Redis的大Key问题是什么?"></a>Redis的大Key问题是什么?</h3><p>Redis 的 “大 Key 问题” 指的是 Redis 中某个 Key 对应的 Value 过大，或集合类 Key（如 Hash、List、Set、ZSet）包含过多元素，导致 Redis 性能下降、运维困难甚至服务不稳定的现象。</p>
<p>没有绝对标准，通常结合业务场景和 Redis 性能表现判断，常见参考阈值：</p>
<ul>
<li><strong>String 类型</strong>：Value 大小超过 100KB（甚至 50KB）即可视为大 Key（如序列化后的大对象、长文本）；</li>
<li><strong>集合类型（Hash&#x2F;List&#x2F;Set&#x2F;ZSet）</strong>：元素数量超过 1 万（甚至 5000），或整体占用内存超过 1MB（如包含百万用户 ID 的 Set、存储大量订单明细的 Hash）。</li>
</ul>
<h4 id="大-Key-的具体表现形式"><a href="#大-Key-的具体表现形式" class="headerlink" title="大 Key 的具体表现形式"></a>大 Key 的具体表现形式</h4><ul>
<li><strong>大 String</strong>：例如存储整个网页 HTML、序列化的大对象（如包含数百个字段的用户信息）、长日志等；</li>
<li><strong>大 Hash</strong>：例如以用户 ID 为 Key，存储该用户的所有行为记录（字段数过万）；</li>
<li><strong>大 List</strong>：例如存储某热门话题的所有评论（元素数几十万）；</li>
<li><strong>大 Set&#x2F;ZSet</strong>：例如存储某大型活动的所有参与用户 ID（元素数上百万）。</li>
</ul>
<h4 id="具体缺点"><a href="#具体缺点" class="headerlink" title="具体缺点"></a>具体缺点</h4><h5 id="1-阻塞-Redis-主线程，降低整体吞吐量"><a href="#1-阻塞-Redis-主线程，降低整体吞吐量" class="headerlink" title="1. 阻塞 Redis 主线程，降低整体吞吐量"></a>1. 阻塞 Redis 主线程，降低整体吞吐量</h5><p>Redis 的核心命令处理是<strong>单线程</strong>的，大 Key 的操作（如<code>GET</code>大 String、<code>HGETALL</code>大 Hash、<code>DEL</code>大集合）会占用大量 CPU 时间，阻塞后续所有命令的执行，导致：</p>
<ul>
<li>其他正常 Key 的请求延迟飙升（从毫秒级增至秒级）；</li>
<li>极端情况下，单条大 Key 操作可能阻塞数秒，引发客户端超时、服务不可用。</li>
</ul>
<h5 id="2-内存分布不均，影响集群负载均衡"><a href="#2-内存分布不均，影响集群负载均衡" class="headerlink" title="2. 内存分布不均，影响集群负载均衡"></a>2. 内存分布不均，影响集群负载均衡</h5><ul>
<li>在 Redis 集群中，大 Key 会导致其所在的节点内存占用远高于其他节点（“数据倾斜”），该节点容易成为整个集群的性能瓶颈（如 CPU、内存使用率过高）；</li>
<li>内存碎片化加剧：大 Key 的频繁创建 &#x2F; 删除可能导致 Redis 内存管理器产生大量碎片（尤其是非连续内存分配），降低实际内存利用率（例如总内存使用率 80%，但可用内存可能仅剩 20%）。</li>
</ul>
<h5 id="3-网络带宽消耗激增"><a href="#3-网络带宽消耗激增" class="headerlink" title="3. 网络带宽消耗激增"></a>3. 网络带宽消耗激增</h5><ul>
<li>读写大 Key 时，需要传输大量数据（如 100KB 的 String 每次<code>GET</code>需传输 100KB 数据），占用服务器与客户端、主从节点之间的网络带宽；</li>
<li>在主从复制或集群数据迁移场景中，大 Key 的同步 &#x2F; 迁移会持续占用网络资源，导致：<ul>
<li>从节点同步延迟（数据落后主节点）；</li>
<li>集群迁移超时（大 Key 传输未完成，触发迁移重试）；</li>
<li>其他正常数据的网络传输被挤占，延迟增加。</li>
</ul>
</li>
</ul>
<h5 id="4-持久化与恢复效率低下"><a href="#4-持久化与恢复效率低下" class="headerlink" title="4. 持久化与恢复效率低下"></a>4. 持久化与恢复效率低下</h5><ul>
<li><strong>RDB 持久化</strong>：生成快照时，大 Key 的序列化会消耗大量 CPU 和 IO 资源，导致 RDB 文件生成时间过长（甚至超时失败），且大 Key 会增大 RDB 文件体积，占用更多磁盘空间；</li>
<li><strong>AOF 持久化</strong>：大 Key 的写命令（如<code>HMSET</code>包含 10 万字段）会生成庞大的 AOF 日志，导致 AOF 文件膨胀，且<code>fsync</code>刷盘时 IO 压力剧增；</li>
<li><strong>数据恢复</strong>：Redis 重启时加载 RDB&#x2F;AOF 文件，解析大 Key 会耗时极长（如加载包含 100 万元素的 Hash 可能需要数十秒），导致服务启动缓慢，可用性下降。</li>
</ul>
<h5 id="5-过期删除与内存淘汰成本高"><a href="#5-过期删除与内存淘汰成本高" class="headerlink" title="5. 过期删除与内存淘汰成本高"></a>5. 过期删除与内存淘汰成本高</h5><ul>
<li>大 Key 过期时，Redis 需要执行删除操作（无论是主动删除还是惰性删除），遍历大集合类 Key 的所有元素会消耗大量 CPU，阻塞主线程；</li>
<li>当 Redis 内存达到<code>maxmemory</code>上限时，内存淘汰机制（如 LRU）筛选和删除大 Key 会比小 Key 更耗时，进一步加剧性能波动。</li>
</ul>
<h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><h5 id="一、针对不同类型大-Key-的拆分策略"><a href="#一、针对不同类型大-Key-的拆分策略" class="headerlink" title="一、针对不同类型大 Key 的拆分策略"></a>一、针对不同类型大 Key 的拆分策略</h5><p>大 Key 的根本问题是 “单 Key 体积过大或元素过多”，拆分的核心是将一个大 Key 拆分为多个小 Key，分散存储压力。</p>
<h6 id="1-String-类型大-Key（如大对象、长文本）"><a href="#1-String-类型大-Key（如大对象、长文本）" class="headerlink" title="1. String 类型大 Key（如大对象、长文本）"></a>1. String 类型大 Key（如大对象、长文本）</h6><p><strong>问题</strong>：单个 String 的 Value 过大（如 100KB 以上，例如序列化的完整用户信息、长日志）。<strong>解决方案</strong>：</p>
<ul>
<li><strong>拆分对象字段</strong>：将大对象拆分为多个小 String，按字段存储。例：原<code>user:1000 &#123;id:1000, name:&quot;xxx&quot;, age:20, ...（100个字段）&#125;</code> → 拆分为<code>user:1000:name</code>、<code>user:1000:age</code>、<code>user:1000:xxx</code>等，每个 Key 仅存储一个字段。优势：减少单 Key 体积，读取时按需获取字段（避免一次性加载全量数据）。</li>
<li><strong>压缩存储</strong>：对长文本（如 JSON、HTML）用压缩算法（如 gzip、snappy）压缩后再存入 Redis，读取时解压。适用场景：文本压缩率高（如重复内容多的日志），且读写频率不极端（避免压缩 &#x2F; 解压开销抵消收益）。</li>
<li><strong>按需缓存</strong>：只缓存高频访问的核心字段，非核心字段直接从数据库查询（避免缓存冗余数据）。</li>
</ul>
<h6 id="2-Hash-类型大-Key（如包含大量字段的哈希表）"><a href="#2-Hash-类型大-Key（如包含大量字段的哈希表）" class="headerlink" title="2. Hash 类型大 Key（如包含大量字段的哈希表）"></a>2. Hash 类型大 Key（如包含大量字段的哈希表）</h6><p><strong>问题</strong>：Hash 的 Field 数量过多（如 10 万 +，例如存储某用户的所有订单记录）。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>按字段范围拆分 Hash：将一个大 Hash 拆分为多个小 Hash，按 Field 的特征（如 ID 范围、哈希值）分配到不同的小 Hash 中。</li>
</ul>
<h6 id="3-List-Set-ZSet-类型大-Key（如包含大量元素的集合）"><a href="#3-List-Set-ZSet-类型大-Key（如包含大量元素的集合）" class="headerlink" title="3. List&#x2F;Set&#x2F;ZSet 类型大 Key（如包含大量元素的集合）"></a>3. List&#x2F;Set&#x2F;ZSet 类型大 Key（如包含大量元素的集合）</h6><p><strong>问题</strong>：List 的元素过多（如 10 万 +，例如热门话题的评论列表）、Set&#x2F;ZSet 的元素过多（如百万 +，例如活动参与用户 ID 集合）。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>按数量 &#x2F; 时间拆分集合</strong>：<ul>
<li>List：按元素数量拆分（如每 1000 个元素一个 List），或按时间拆分（如每天一个 List，<code>comment:topic:100:20231001</code>、<code>comment:topic:100:20231002</code>）。</li>
<li>Set&#x2F;ZSet：按元素的哈希值拆分（如用户 ID 模 50，分散到 50 个 Set 中），或按范围拆分（如用户 ID 1-10000 存<code>user:act:1</code>，10001-20000 存<code>user:act:2</code>）。</li>
</ul>
</li>
<li><strong>用 ZSet 替代 List 做分页</strong>：若 List 用于分页查询（如 “最新 100 条评论”），可改用 ZSet（Score 为时间戳），按 Score 范围查询，避免 List 的<code>lrange</code>操作遍历大量元素。</li>
</ul>
<h5 id="二、删除大-Key-的特殊处理"><a href="#二、删除大-Key-的特殊处理" class="headerlink" title="二、删除大 Key 的特殊处理"></a>二、删除大 Key 的特殊处理</h5><p>直接用<code>DEL</code>命令删除大 Key（尤其是集合类）会阻塞 Redis 主线程（单线程需遍历所有元素），需用<strong>异步删除</strong>：</p>
<ul>
<li>Redis 4.0 + 提供UNLINK命令：将大 Key 的删除操作放入后台线程执行，主线程不阻塞（仅记录删除任务后立即返回）。</li>
<li>若使用低版本 Redis，可分批删除集合元素（如用<code>SPOP</code>每次删 100 个元素，循环执行直到集合为空），避免单次操作耗时过长。</li>
</ul>
<h3 id="什么是热key"><a href="#什么是热key" class="headerlink" title="什么是热key?"></a>什么是热key?</h3><p>热 key（热点 Key）指的是在<strong>短时间内被异常高频访问</strong>的 Redis 键（Key），其访问量远高于其他普通 Key，导致该 Key 所在的 Redis 节点（或服务器）承受巨大的负载压力，甚至成为整个系统的性能瓶颈。</p>
<p>热 key 的核心特征：</p>
<ol>
<li><strong>访问频率极高</strong>：单位时间内的请求量远超其他 Key（例如，某 Key 每秒被访问 10 万次，而普通 Key 仅几十次）；</li>
<li><strong>时间集中性</strong>：访问往往集中在某个时间段爆发（如秒杀活动开始时的商品 ID、突发热门事件的相关 Key）；</li>
<li><strong>节点绑定</strong>：在 Redis 集群中，热 key 会固定落在负责其哈希槽的某个主节点上，导致该节点成为 “热点节点”。</li>
</ol>
<p>举例说明：</p>
<ul>
<li>电商平台的 “秒杀商品 ID”：活动开始后， millions of 用户同时刷新该商品详情，对应的缓存 Key（如<code>goods:10086</code>）被高频访问；</li>
<li>社交平台的 “热门话题 ID”：某事件突发后，大量用户查询该话题内容，对应的<code>topic:999</code>成为热 key；</li>
<li>直播平台的 “主播在线状态 Key”：头部主播开播时， millions of 粉丝同时查看其状态，<code>live:user:888</code>被频繁读取。</li>
</ul>
<p>如何解决：</p>
<p><strong>多副本存储</strong>（热 key 复制到多个节点）：将热 key 复制到 Redis 集群的多个节点（主节点），客户端访问时随机选择一个副本，分散单个节点的压力。</p>
<p><strong>本地缓存</strong>（应用层缓存热 key）：在应用服务器的本地内存中缓存热 key（如 Java 用 Caffeine、Python 用 functools.lru_cache），减少对 Redis 的直接访问。</p>
<p> <strong>热 key 拆分</strong>（将一个热 key 拆分为多个子 key）：若热 key 的 Value 可拆分（如计数、集合），将其拆分为多个子 key，分散到 Redis 集群的不同节点，客户端访问时随机选择子 key 操作。</p>
<p><strong>读写分离 + 主从扩容</strong>（针对读热 key）：若热 key 是 “读多写少” 类型，可给其所在的主节点增加更多从节点，将读请求分流到从节点，减轻主节点压力。</p>
<h3 id="如何保证-redis-和-mysql-数据缓存一致性问题"><a href="#如何保证-redis-和-mysql-数据缓存一致性问题" class="headerlink" title="如何保证 redis 和 mysql 数据缓存一致性问题?"></a>如何保证 redis 和 mysql 数据缓存一致性问题?</h3><p>保证 Redis 与 MySQL 的数据缓存一致性，核心是解决 “缓存数据与数据库数据不同步” 的问题。由于两者的存储特性（内存 vs 磁盘）和更新机制不同，需根据业务对一致性的要求（最终一致性 &#x2F; 强一致性）、读写频率等选择方案。以下是经过实践验证的主流方案：</p>
<h4 id="一、核心原则：优先-“删缓存”，而非-“更缓存”"><a href="#一、核心原则：优先-“删缓存”，而非-“更缓存”" class="headerlink" title="一、核心原则：优先 “删缓存”，而非 “更缓存”"></a>一、核心原则：优先 “删缓存”，而非 “更缓存”</h4><p>直接更新缓存（如<code>set cache_key new_value</code>）容易引发并发冲突：例如，两个线程同时更新数据库，若线程 A 先更新缓存，线程 B 后更新缓存，但 B 的数据库更新晚于 A，会导致缓存存 B 的旧值。更安全的做法是<strong>删除缓存</strong>（让后续请求从数据库加载最新数据到缓存），配合过期时间兜底（即使偶发不一致，缓存过期后也会自动同步）。</p>
<h4 id="二、主流方案详解"><a href="#二、主流方案详解" class="headerlink" title="二、主流方案详解"></a>二、主流方案详解</h4><h5 id="1-旁路缓存模式（Cache-Aside-Pattern）：先更-DB，再删缓存"><a href="#1-旁路缓存模式（Cache-Aside-Pattern）：先更-DB，再删缓存" class="headerlink" title="1. 旁路缓存模式（Cache-Aside Pattern）：先更 DB，再删缓存"></a>1. 旁路缓存模式（Cache-Aside Pattern）：先更 DB，再删缓存</h5><p><strong>适用场景</strong>：读多写少、对一致性要求为 “最终一致”（如商品详情、用户信息）。</p>
<p><strong>流程</strong>：</p>
<ul>
<li><strong>读操作</strong>：先查 Redis，命中则返回；未命中则查 MySQL，再将结果写入 Redis 后返回。</li>
<li><strong>写操作</strong>：先更新 MySQL，再删除 Redis 中对应的缓存（而非更新缓存）。</li>
</ul>
<p><strong>为什么有效</strong>：删除缓存后，后续读请求会从 MySQL 加载最新数据到 Redis，自然恢复一致性。</p>
<p><strong>潜在问题</strong>：若 “更新 MySQL 成功” 但 “删除 Redis 失败”（如网络波动），会导致缓存留存旧数据。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>重试机制</strong>：删除缓存失败时，将 “删除任务” 丢入消息队列（如 RabbitMQ），通过消费者重试删除（设置 3-5 次重试上限，间隔递增如 1s→3s→5s，避免无效循环）。</li>
<li><strong>定时校验</strong>：定时任务（如每 5 分钟）对比缓存与 MySQL 的 “数据版本号”（需额外存储），若缓存版本落后，则删除缓存或重新同步。</li>
</ul>
<h5 id="2-先删缓存，再更-DB-延迟双删"><a href="#2-先删缓存，再更-DB-延迟双删" class="headerlink" title="2. 先删缓存，再更 DB + 延迟双删"></a>2. 先删缓存，再更 DB + 延迟双删</h5><p><strong>适用场景</strong>：写操作较频繁，需避免 “缓存污染”（旧数据被误写入缓存）。</p>
<p><strong>解决的问题</strong>：若 “删缓存后、DB 更新前” 有请求查询，会从 DB 读旧数据并写入缓存，导致后续不一致。例如：</p>
<ul>
<li>线程 A：删除缓存 → 开始更新 DB（未完成）；</li>
<li>线程 B：查询数据 → 缓存已删，查 DB 旧数据 → 写入缓存；</li>
<li>线程 A：更新 DB 完成 → 此时缓存中是 B 写入的旧数据，不一致。</li>
</ul>
<p><strong>流程优化</strong>：写操作 &#x3D; 先删缓存 → 更新 DB → 延迟一段时间（如 500ms）后<strong>再次删除缓存</strong>。</p>
<p><strong>第二次删除的作用</strong>：等线程 B 完成 “查旧 DB→写旧缓存” 后，再删一次缓存，清除旧数据。后续请求会从 DB 加载最新数据。</p>
<p><strong>注意</strong>：延迟时间需根据业务耗时调整（如通过压测确定 DB 更新 + 缓存写入的最大耗时），通常设为 500ms-1s。</p>
<h5 id="3-基于-Binlog-的异步同步（Canal-方案）"><a href="#3-基于-Binlog-的异步同步（Canal-方案）" class="headerlink" title="3. 基于 Binlog 的异步同步（Canal 方案）"></a>3. 基于 Binlog 的异步同步（Canal 方案）</h5><p><strong>适用场景</strong>：多服务共享数据、缓存更新逻辑复杂（如多表关联更新）。</p>
<p><strong>原理</strong>：利用 MySQL 的 Binlog 日志（记录所有数据库变更），通过 Canal（阿里开源工具）监听 Binlog，实时感知 DB 变化，异步更新 &#x2F; 删除 Redis 缓存。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>Canal 模拟 MySQL 从库，订阅主库的 Binlog；</li>
<li>MySQL 数据更新时，Canal 捕获变更事件（如<code>update</code>&#x2F;<code>delete</code>）；</li>
<li>Canal 将事件推送给消息队列，消费端根据事件更新 &#x2F; 删除对应的 Redis 缓存。</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li>解耦缓存更新逻辑（业务代码无需嵌入删缓存逻辑）；</li>
<li>支持多服务场景（避免各服务重复处理缓存）。</li>
</ul>
<p><strong>缺点</strong>：存在毫秒级延迟（Binlog 同步→缓存更新），适合最终一致性场景。</p>
<h5 id="4-强一致性方案：加锁-双写"><a href="#4-强一致性方案：加锁-双写" class="headerlink" title="4. 强一致性方案：加锁 + 双写"></a>4. 强一致性方案：加锁 + 双写</h5><p><strong>适用场景</strong>：对一致性要求极高（如金融交易、库存扣减），可接受性能损耗。</p>
<p><strong>流程</strong>：</p>
<ul>
<li><strong>写操作</strong>：加分布式锁 → 更新 MySQL → 更新 Redis → 释放锁；</li>
<li><strong>读操作</strong>：加分布式锁 → 查 Redis（未命中则查 MySQL 并回写 Redis） → 释放锁。</li>
</ul>
<p><strong>原理</strong>：通过锁保证 “读写互斥”，避免并发导致的不一致。</p>
<p><strong>缺点</strong>：锁会降低并发性能（读写均需等待锁），仅适合低并发、高一致性场景。</p>
<h4 id="三、必加兜底：缓存过期时间"><a href="#三、必加兜底：缓存过期时间" class="headerlink" title="三、必加兜底：缓存过期时间"></a>三、必加兜底：缓存过期时间</h4><p>无论采用哪种方案，都需为 Redis 缓存设置<strong>合理的过期时间</strong>（如 5-10 分钟）。即使出现偶发不一致（如删除缓存失败、延迟时间不足），缓存过期后会被自动淘汰，后续请求从 DB 加载最新数据，保证 “最终一致性”。</p>
<h3 id="缓存雪崩、击穿、穿透是什么-怎么解决"><a href="#缓存雪崩、击穿、穿透是什么-怎么解决" class="headerlink" title="缓存雪崩、击穿、穿透是什么?怎么解决?"></a>缓存雪崩、击穿、穿透是什么?怎么解决?</h3><ul>
<li><ul>
<li><p>穿透：缓存穿透是指<strong>请求查询的数据在缓存和数据库中都不存在</strong>，导致每次请求都会 “穿透” 缓存，直接访问数据库。</p>
</li>
<li><ul>
<li><strong>缓存空值（Null Cache）</strong>当数据库返回空结果时，也将空值写入缓存，并设置较短的过期时间（如 3~5 分钟）。</li>
<li><strong>布隆过滤器（Bloom Filter）</strong>将所有存在的 Key 哈希到一个位数组中，请求先经过布隆过滤器判断是否可能存在。</li>
</ul>
</li>
<li><p>击穿：<strong>某个热点 Key 突然过期</strong>，而此时恰好有大量请求查询该 Key，这些请求会同时绕过缓存，集中访问数据库。</p>
</li>
<li><ul>
<li><strong>互斥锁（分布式锁）</strong>当缓存失效时，只有第一个请求能获取锁去数据库查询，其他请求等待并重试。用这个setnx命令或者Redisson 分布式锁</li>
<li>对热点 Key 不设置过期时间，通过后台任务定时更新缓存。</li>
</ul>
</li>
<li><p>雪崩：<strong>缓存中大量 Key 在同一时间段内集中过期</strong>，或缓存服务器集群整体故障，导致海量请求无法从缓存获取数据，全部涌向数据库。</p>
</li>
<li><ul>
<li>过期时间随机化：在设置过期时间时增加一个随机值（如 30 分钟 ± 5 分钟），避免大量 Key 同时过期。</li>
<li>缓存集群化：使用 Redis Cluster 或主从 + 哨兵模式，避免单点故障。</li>
<li>熔断降级处理:当缓存失效或数据库压力过大时，通过熔断机制直接返回默认数据或错误提示，保护后端。</li>
<li>限流处理：对数据库入口做限流保护，防止瞬时请求量过大。</li>
<li>多级缓存：结合本地缓存（Caffeine、Guava）+ 分布式缓存（Redis），减少对单一缓存层的依赖。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="布隆过滤器原理介绍一下"><a href="#布隆过滤器原理介绍一下" class="headerlink" title="布隆过滤器原理介绍一下"></a>布隆过滤器原理介绍一下</h3><p><strong>布隆过滤器（Bloom Filter）</strong></p>
<p>布隆过滤器是一种高效的<strong>空间优化型数据结构</strong>，用于判断一个元素是否“可能存在”或“一定不存在”。</p>
<p><strong>原理：</strong></p>
<ul>
<li><p>初始化一个长度为 m 的 bit 数组（全 0）。</p>
</li>
<li><p>定义 k 个哈希函数。</p>
</li>
<li><p>每插入一个元素，计算它的 k 个哈希值，将对应位置设为 1。</p>
</li>
<li><p>判断是否存在：检查所有哈希位置是否都是 1。</p>
</li>
<li><ul>
<li>如果有 0 → 一定不存在</li>
<li>如果全是 1 → 可能存在（存在误判）</li>
</ul>
</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>缓存穿透防护（Redis + 布隆过滤器）</li>
<li>黑名单快速判断</li>
<li>垃圾邮件过滤、爬虫去重等</li>
</ul>
<h3 id="如何设计秒杀场景处理高并发以及超卖现象"><a href="#如何设计秒杀场景处理高并发以及超卖现象" class="headerlink" title="如何设计秒杀场景处理高并发以及超卖现象?"></a>如何设计秒杀场景处理高并发以及超卖现象?</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户 → 前端（验证码/排队） → CDN（静态资源） → Nginx（限流） → 应用服务（接口限流/熔断） → 消息队列（削峰） → 消费者（处理订单）</span><br><span class="line">                                                                   ↓</span><br><span class="line">Redis（原子扣减库存） ← 库存预热 ← MySQL（原始库存）</span><br><span class="line">                                                                   ↓</span><br><span class="line">MySQL（最终扣减库存，带条件更新）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>按钮置灰与防重复提交</strong>：用户点击秒杀按钮后立即置灰，禁止重复点击；通过前端防抖（如 1 秒内只允许 1 次请求）减少重复提交。</li>
<li><strong>验证码 &#x2F; 排队机制</strong>：秒杀开始前要求用户输入图形验证码或完成滑块验证，过滤机器人脚本；将用户放入前端排队队列（如显示 “排队中，第 XX 位”），分散请求发送时间。</li>
<li><strong>静态资源 CDN 化</strong>：秒杀页面的 HTML、CSS、JS、图片等静态资源全部部署到 CDN，避免请求穿透到应用服务器。</li>
<li><strong>Nginx 限流</strong>：通过<code>limit_req</code>模块设置每秒最大请求数（如限制单 IP 每秒 5 次请求），超过阈值直接返回 “系统繁忙”。</li>
<li><strong>黑名单拦截</strong>：通过网关拦截频繁请求的恶意 IP（如 1 分钟内请求超过 100 次），加入临时黑名单。</li>
<li><strong>接口限流</strong>：在应用服务中通过 Redis 实现分布式限流（如滑动窗口算法），限制秒杀接口的全局 QPS（如每秒 1 万次），超过则返回降级提示。</li>
<li><strong>服务熔断降级</strong>：使用 Sentinel&#x2F;Hystrix 等组件，当服务响应时间超过阈值或错误率过高时，自动熔断，返回 “稍候再试” 等友好提示，避免服务雪崩。</li>
<li>通过消息队列（如 RabbitMQ、Redis List）将同步请求转为异步处理，将瞬时高流量 “削平” 为匀速流量</li>
</ul>
<h4 id="防超卖：库存操作的原子性与一致性"><a href="#防超卖：库存操作的原子性与一致性" class="headerlink" title="防超卖：库存操作的原子性与一致性"></a>防超卖：库存操作的原子性与一致性</h4><p>超卖的本质是 “库存扣减非原子化”（如并发查库存→扣库存导致多扣），需通过 “预扣减 + 原子操作 + 多层校验” 保证库存安全。</p>
<h5 id="1-库存预热：Redis-预存库存（快速判断）"><a href="#1-库存预热：Redis-预存库存（快速判断）" class="headerlink" title="1. 库存预热：Redis 预存库存（快速判断）"></a>1. 库存预热：Redis 预存库存（快速判断）</h5><p>秒杀开始前，将商品库存从 MySQL 加载到 Redis（如<code>seckill:stock:1001 → 100</code>），后续库存判断和扣减优先操作 Redis（内存操作，支持高并发）。</p>
<ul>
<li>预热时机：秒杀活动开始前 5-10 分钟，通过定时任务从 MySQL 同步库存到 Redis。</li>
<li>优势：避免秒杀开始时大量请求查询 MySQL，减轻数据库压力。</li>
</ul>
<h5 id="2-Redis-原子扣减：拦截超量请求（核心防超卖）"><a href="#2-Redis-原子扣减：拦截超量请求（核心防超卖）" class="headerlink" title="2. Redis 原子扣减：拦截超量请求（核心防超卖）"></a>2. Redis 原子扣减：拦截超量请求（核心防超卖）</h5><p>利用 Redis 的<code>DECR</code>命令（原子操作）预扣库存，确保同一时间只有一个请求能成功扣减：</p>
<ul>
<li><strong>流程</strong>：用户请求进入后，先执行<code>DECR seckill:stock:1001</code>，若返回值≥0，说明库存充足，允许继续下单；若返回值 &lt;0，直接返回 “已抢完”。</li>
<li><strong>原理</strong>：<code>DECR</code>是单线程原子操作，即使数万并发请求同时执行，也能保证库存扣减的准确性，避免超卖。</li>
</ul>
<h5 id="3-MySQL-最终校验：保证数据一致性（兜底机制）"><a href="#3-MySQL-最终校验：保证数据一致性（兜底机制）" class="headerlink" title="3. MySQL 最终校验：保证数据一致性（兜底机制）"></a>3. MySQL 最终校验：保证数据一致性（兜底机制）</h5><p>Redis 扣减成功后，需异步同步到 MySQL（通过消息队列消费），此时需再次校验 MySQL 库存，避免 Redis 与 MySQL 不一致导致的超卖：</p>
<ul>
<li><p>SQL 层面：扣减库存时用带条件的更新语句（利用 MySQL 行锁保证原子性）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 仅当库存&gt;0时才扣减，返回影响行数（1=成功，0=失败）</span></span><br><span class="line"><span class="keyword">UPDATE</span> seckill_goods </span><br><span class="line"><span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> goods_id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">AND</span> stock <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若更新影响行数为 0，说明 MySQL 实际库存已不足，需回滚 Redis 库存（<code>INCR seckill:stock:1001</code>），并取消用户订单。</p>
</li>
</ul>
<h5 id="4-库存一致性维护"><a href="#4-库存一致性维护" class="headerlink" title="4. 库存一致性维护"></a>4. 库存一致性维护</h5><ul>
<li><strong>定时对账</strong>：启动定时任务（如每秒一次），对比 Redis 库存与 MySQL 库存，若存在差异（如 Redis 因网络问题未扣减），以 MySQL 为准修正 Redis。</li>
<li><strong>最终库存锁定</strong>：订单创建后设置 15 分钟支付超时，未支付则释放库存（Redis+MySQL 同时加回），避免库存长期占用。</li>
</ul>
<h3 id="假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以-某个固定的已知的前缀开头的，-如何将它们全部找出来？"><a href="#假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以-某个固定的已知的前缀开头的，-如何将它们全部找出来？" class="headerlink" title="假如 Redis 里面有 1 亿个   key，其中有 10w 个 key 是以 某个固定的已知的前缀开头的， 如何将它们全部找出来？"></a>假如 Redis 里面有 1 亿个   key，其中有 10w 个 key 是以 某个固定的已知的前缀开头的， 如何将它们全部找出来？</h3><p>首先禁止使用 <code>KEYS</code> 命令，keys prefix*虽然可以返回所有匹配前缀的key，阻塞Redis单线程执行期间无法处理其他命令；内存消耗激增，可能导致OOM</p>
<p><code>SCAN</code> 是 Redis 2.8+ 提供的渐进式遍历命令，通过<strong>游标迭代</strong>的方式分批返回匹配的 key，每次扫描只处理部分数据，不会阻塞 Redis 服务，适合处理大规模 key 场景。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法：SCAN cursor [MATCH pattern] [COUNT count]</span></span><br><span class="line"><span class="comment"># cursor：游标（初始为0，每次扫描后返回新游标，直到游标为0表示遍历完成）</span></span><br><span class="line"><span class="comment"># MATCH：匹配模式（如 &quot;prefix*&quot; 匹配前缀为prefix的key）</span></span><br><span class="line"><span class="comment"># COUNT：指定每次扫描的&quot;预估数量&quot;（非精确值，Redis会根据内部数据结构调整）</span></span><br></pre></td></tr></table></figure>

<h3 id="MySQL-里有-2000w-数据，-redis-中只存-20w-的数据，如-何保证-redis-中的数据都是热点-数据？"><a href="#MySQL-里有-2000w-数据，-redis-中只存-20w-的数据，如-何保证-redis-中的数据都是热点-数据？" class="headerlink" title="MySQL 里有 2000w 数据，  redis 中只存 20w 的数据，如 何保证 redis 中的数据都是热点 数据？"></a>MySQL 里有 2000w 数据，  redis 中只存 20w 的数据，如 何保证 redis 中的数据都是热点 数据？</h3><p>首先需通过<code>maxmemory</code>和<code>maxmemory-policy</code>配置，限制 Redis 缓存的 “数据量” 或 “内存占用”（假设每条数据平均 1KB，20 万条约 200MB，可据此设置<code>maxmemory</code>）</p>
<p>推荐<code>allkeys-lfu</code>：比<code>lru</code>更精准（<code>lru</code>可能误淘汰 “曾经热、近期没访问但未来可能热” 的数据，<code>lfu</code>基于访问频率，更贴合 “热点” 定义）。</p>
<p>避免一次性将 MySQL 的 2000 万数据全量加载到 Redis，而是<strong>按需加载</strong>（仅当数据被访问时才加载），确保进入 Redis 的数据都是 “被访问过的”</p>
<ol>
<li><strong>基础配置</strong>：Redis 开启<code>maxmemory=200mb</code>和<code>maxmemory-policy=allkeys-lfu</code>，自动淘汰冷数据。</li>
<li><strong>业务埋点</strong>：统计数据访问频率，仅将高频数据写入 Redis，减少冷数据进入。</li>
<li><strong>定时同步</strong>：每 5 分钟筛选 Top20 万热点数据，同步到 Redis 并删除冷数据，严格控制数量。</li>
<li><strong>优化防护</strong>：用 Cache-Aside 模式更新缓存，布隆过滤器防穿透，核心热点数据永不过期。</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">北川</div><div class="post-copyright__author_desc">Believe in yourself</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://gukeyang.github.io/posts/adbd2430.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://gukeyang.github.io/posts/adbd2430.html')">Redis面试题</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wecaht/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://gukeyang.github.io/posts/adbd2430.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Redis面试题&amp;url=https://gukeyang.github.io/posts/adbd2430.html&amp;pic=https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=cdc92548-a3c3-d014-7322-6a9bc2cd18dd" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gukeyang.github.io" target="_blank">北川的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Redis/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Redis<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/10/23/pH7DOX5rqdLCk4b.jpg?_r_=d0373d96-8ded-1918-75db-bc79c24292e2" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/489ef953.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/5MFUXBI3EhCAx6y.jpg?_r_=2c02a8c9-a9b0-c8d0-7189-7ba9b1a2bb53" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/a0d0ac1c.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=9f73e914-1418-a81d-00c3-4cc2d3cc9b8b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mybatis面试题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/zc998800/cdn/face/gif/m17.gif" ait="status"/></div></div><div class="author-info__description">路慢其修远兮 吾将上下而求索</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">北川</h1><div class="author-info__desc">Believe in yourself</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/gukeyang" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1542898061" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://s2.loli.net/2023/10/19/vNio4QGBSX9x5lO.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis"><span class="toc-number">1.</span> <span class="toc-text">什么是Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Redis系统架构模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-number">3.</span> <span class="toc-text">Redis为什么快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">Redis的基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%90%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">Redis各数据类型有哪些应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%B8%AD-set%E5%92%8Czset%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">Redis 中 set和zset区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BD%BF%E7%94%A8%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">Redis哪些地方使用了多线程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">Redis怎么实现的io多路复用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0redis-%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">如何实现redis 原子性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%8D%95%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9A%84%E5%A4%A9%E7%84%B6%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">9.1.</span> <span class="toc-text">1. 单线程执行模型：单个命令的天然原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8B%E5%8A%A1%EF%BC%88MULTI-EXEC%EF%BC%89%EF%BC%9A%E5%A4%9A%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E6%89%93%E5%8C%85"><span class="toc-number">9.2.</span> <span class="toc-text">2. 事务（MULTI&#x2F;EXEC）：多命令的原子性打包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Lua-%E8%84%9A%E6%9C%AC%EF%BC%9A%E5%A4%8D%E6%9D%82%E9%80%BB%E8%BE%91%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">3. Lua 脚本：复杂逻辑的原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8E%9F%E7%94%9F%E5%8E%9F%E5%AD%90%E5%91%BD%E4%BB%A4%EF%BC%9A%E9%AB%98%E9%A2%91%E5%9C%BA%E6%99%AF%E7%9A%84%E7%AE%80%E5%8C%96%E6%94%AF%E6%8C%81"><span class="toc-number">9.4.</span> <span class="toc-text">4. 原生原子命令：高频场景的简化支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">Redis 事务的基本命令有哪些？执行流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">11.</span> <span class="toc-text">Redis的持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E6%97%A5%E5%BF%97"><span class="toc-number">11.1.</span> <span class="toc-text">AOF 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">11.1.1.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6"><span class="toc-number">11.1.2.</span> <span class="toc-text">关键机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">11.1.3.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-%E5%BF%AB%E7%85%A7"><span class="toc-number">11.2.</span> <span class="toc-text">RDB 快照</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">11.2.1.</span> <span class="toc-text">触发方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">11.2.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E5%92%8C%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-number">12.</span> <span class="toc-text">缓存淘汰和过期删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%EF%BC%88%E5%A4%84%E7%90%86%E5%B7%B2%E8%BF%87%E6%9C%9F%E7%9A%84%E9%94%AE%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">一、过期删除策略（处理已过期的键）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%EF%BC%88Lazy-Expiration%EF%BC%89"><span class="toc-number">12.1.1.</span> <span class="toc-text">1. 惰性删除（Lazy Expiration）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%EF%BC%88Periodic-Expiration%EF%BC%89"><span class="toc-number">12.1.2.</span> <span class="toc-text">2. 定期删除（Periodic Expiration）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%97%B6%E6%B7%98%E6%B1%B0%E9%94%AE%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">二、缓存淘汰策略（内存不足时淘汰键）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%AA%E6%B7%98%E6%B1%B0-%E2%80%9C%E8%AE%BE%E7%BD%AE%E4%BA%86%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E2%80%9D-%E7%9A%84%E9%94%AE%EF%BC%88volatile-%EF%BC%89"><span class="toc-number">12.2.1.</span> <span class="toc-text">1. 只淘汰 “设置了过期时间” 的键（volatile-*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B7%98%E6%B1%B0%E6%89%80%E6%9C%89%E9%94%AE%EF%BC%88%E5%8C%85%E6%8B%AC%E6%9C%AA%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%EF%BC%8Callkeys-%EF%BC%89"><span class="toc-number">12.2.2.</span> <span class="toc-text">2. 淘汰所有键（包括未设置过期时间的，allkeys-*）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%8D%E6%B7%98%E6%B1%B0%E9%94%AE%EF%BC%88noeviction%EF%BC%89"><span class="toc-number">12.2.3.</span> <span class="toc-text">3. 不淘汰键（noeviction）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%AD%E7%9A%84%E5%A2%9E%E9%87%8F%E5%92%8C%E5%AE%8C%E5%85%A8%E5%90%8C%E6%AD%A5%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">主从同步中的增量和完全同步怎么实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%90%8C%E6%AD%A5"><span class="toc-number">13.1.</span> <span class="toc-text">完全同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">13.2.</span> <span class="toc-text">增量同步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%92%8C%E9%9B%86%E7%BE%A4%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%90%97-%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">Redis主从和集群可以保证数据一致性吗 ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">14.1.</span> <span class="toc-text">一、主从架构的一致性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Redis-Cluster%EF%BC%88%E9%9B%86%E7%BE%A4%EF%BC%89%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">14.2.</span> <span class="toc-text">二、Redis Cluster（集群）的一致性问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%93%A8%E5%85%B5%EF%BC%88Sentinel%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">15.</span> <span class="toc-text">Redis 哨兵（Sentinel）机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%93%A8%E5%85%B5%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">15.1.</span> <span class="toc-text">一、哨兵的核心功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%93%A8%E5%85%B5%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">15.2.</span> <span class="toc-text">二、哨兵的架构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%93%A8%E5%85%B5%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">15.3.</span> <span class="toc-text">三、哨兵的工作原理（核心流程）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%9B%91%E6%8E%A7%E4%B8%8E%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%EF%BC%88%E8%8A%82%E7%82%B9%E5%81%A5%E5%BA%B7%E6%A3%80%E6%B5%8B%EF%BC%89"><span class="toc-number">15.3.1.</span> <span class="toc-text">1. 监控与状态判断（节点健康检测）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E8%A7%A6%E5%8F%91%EF%BC%88%E5%BD%93%E4%B8%BB%E8%8A%82%E7%82%B9-%E2%80%9C%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF%E2%80%9D-%E5%90%8E%EF%BC%89"><span class="toc-number">15.3.2.</span> <span class="toc-text">2. 故障转移触发（当主节点 “客观下线” 后）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B0%E4%B8%BB%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE%EF%BC%88%E4%BB%8E%E4%BB%8E%E8%8A%82%E7%82%B9%E4%B8%AD%E9%80%89%E4%B8%80%E4%B8%AA%E5%8D%87%E7%BA%A7%E4%B8%BA%E4%B8%BB%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">15.3.3.</span> <span class="toc-text">3. 新主节点选举（从从节点中选一个升级为主节点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%89%A7%E8%A1%8C%EF%BC%88%E6%9B%B4%E6%96%B0%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">15.3.4.</span> <span class="toc-text">4. 故障转移执行（更新拓扑结构）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8E%9F%E4%B8%BB%E8%8A%82%E7%82%B9%E6%81%A2%E5%A4%8D%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">15.3.5.</span> <span class="toc-text">5. 原主节点恢复后的处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BC%98%E7%BC%BA%E7%82%B9%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">16.</span> <span class="toc-text">Redis集群的模式了解吗 优缺点了解吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%AE%BE%E8%AE%A1%E7%89%B9%E7%82%B9%EF%BC%89"><span class="toc-number">16.1.</span> <span class="toc-text">一、Redis 集群的核心模式（设计特点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E6%A7%BD%EF%BC%88Hash-Slot%EF%BC%89"><span class="toc-number">16.1.1.</span> <span class="toc-text">1. 数据分片：基于哈希槽（Hash Slot）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">16.1.2.</span> <span class="toc-text">2. 主从复制与故障转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-number">16.1.3.</span> <span class="toc-text">3. 去中心化设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%B9%E9%94%99%E4%B8%8E%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="toc-number">16.1.4.</span> <span class="toc-text">4. 容错与可用性保障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">16.2.</span> <span class="toc-text">二、Redis 集群的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">16.3.</span> <span class="toc-text">三、Redis 集群的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="toc-number">16.4.</span> <span class="toc-text">四、适用场景与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98-%E9%87%8D%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">场景题(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8redis"><span class="toc-number">17.1.</span> <span class="toc-text">为什么使用redis?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88redis%E6%AF%94mysql%E8%A6%81%E5%BF%AB"><span class="toc-number">17.2.</span> <span class="toc-text">为什么redis比mysql要快?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8CRedis%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.3.</span> <span class="toc-text">本地缓存和Redis缓存的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">17.4.</span> <span class="toc-text">redis应用场景是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">17.5.</span> <span class="toc-text">Redis分布式锁的实现原理?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%A0%E9%94%81%EF%BC%9A%E9%80%9A%E8%BF%87SET%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="toc-number">17.5.1.</span> <span class="toc-text">1. 加锁：通过SET命令的原子性实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8A%E6%94%BE%E9%94%81%EF%BC%9A%E9%80%9A%E8%BF%87-Lua-%E8%84%9A%E6%9C%AC%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">17.5.2.</span> <span class="toc-text">2. 释放锁：通过 Lua 脚本保证原子性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%94%A8%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">17.6.</span> <span class="toc-text">什么场景下用到分布式锁?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%EF%BC%88%E9%98%B2%E6%AD%A2%E8%B6%85%E5%8D%96%EF%BC%89"><span class="toc-number">17.6.1.</span> <span class="toc-text">1. 库存扣减（防止超卖）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">17.6.2.</span> <span class="toc-text">2. 定时任务（防止重复执行）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E8%B7%A8%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%89"><span class="toc-number">17.6.3.</span> <span class="toc-text">3. 分布式事务（跨服务数据一致性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E4%BF%AE%E6%94%B9%EF%BC%88%E9%98%B2%E6%AD%A2%E8%84%8F%E5%86%99%EF%BC%89"><span class="toc-number">17.6.4.</span> <span class="toc-text">4. 共享资源修改（防止脏写）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%EF%BC%88%E6%8E%A7%E5%88%B6%E5%85%A8%E5%B1%80%E5%B9%B6%E5%8F%91%E9%87%8F%EF%BC%89"><span class="toc-number">17.6.5.</span> <span class="toc-text">5. 分布式限流（控制全局并发量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%86%E5%B8%83%E5%BC%8F-ID-%E7%94%9F%E6%88%90%EF%BC%88%E4%BF%9D%E8%AF%81-ID-%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%89"><span class="toc-number">17.6.6.</span> <span class="toc-text">6. 分布式 ID 生成（保证 ID 唯一性）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%A4%A7Key%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">17.7.</span> <span class="toc-text">Redis的大Key问题是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7-Key-%E7%9A%84%E5%85%B7%E4%BD%93%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">17.7.1.</span> <span class="toc-text">大 Key 的具体表现形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%BC%BA%E7%82%B9"><span class="toc-number">17.7.2.</span> <span class="toc-text">具体缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%98%BB%E5%A1%9E-Redis-%E4%B8%BB%E7%BA%BF%E7%A8%8B%EF%BC%8C%E9%99%8D%E4%BD%8E%E6%95%B4%E4%BD%93%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">17.7.2.1.</span> <span class="toc-text">1. 阻塞 Redis 主线程，降低整体吞吐量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%EF%BC%8C%E5%BD%B1%E5%93%8D%E9%9B%86%E7%BE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">17.7.2.2.</span> <span class="toc-text">2. 内存分布不均，影响集群负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD%E6%B6%88%E8%80%97%E6%BF%80%E5%A2%9E"><span class="toc-number">17.7.2.3.</span> <span class="toc-text">3. 网络带宽消耗激增</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E6%81%A2%E5%A4%8D%E6%95%88%E7%8E%87%E4%BD%8E%E4%B8%8B"><span class="toc-number">17.7.2.4.</span> <span class="toc-text">4. 持久化与恢复效率低下</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%88%90%E6%9C%AC%E9%AB%98"><span class="toc-number">17.7.2.5.</span> <span class="toc-text">5. 过期删除与内存淘汰成本高</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">17.7.3.</span> <span class="toc-text">如何解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%A4%A7-Key-%E7%9A%84%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5"><span class="toc-number">17.7.3.1.</span> <span class="toc-text">一、针对不同类型大 Key 的拆分策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-String-%E7%B1%BB%E5%9E%8B%E5%A4%A7-Key%EF%BC%88%E5%A6%82%E5%A4%A7%E5%AF%B9%E8%B1%A1%E3%80%81%E9%95%BF%E6%96%87%E6%9C%AC%EF%BC%89"><span class="toc-number">17.7.3.1.1.</span> <span class="toc-text">1. String 类型大 Key（如大对象、长文本）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-Hash-%E7%B1%BB%E5%9E%8B%E5%A4%A7-Key%EF%BC%88%E5%A6%82%E5%8C%85%E5%90%AB%E5%A4%A7%E9%87%8F%E5%AD%97%E6%AE%B5%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">17.7.3.1.2.</span> <span class="toc-text">2. Hash 类型大 Key（如包含大量字段的哈希表）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-List-Set-ZSet-%E7%B1%BB%E5%9E%8B%E5%A4%A7-Key%EF%BC%88%E5%A6%82%E5%8C%85%E5%90%AB%E5%A4%A7%E9%87%8F%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">17.7.3.1.3.</span> <span class="toc-text">3. List&#x2F;Set&#x2F;ZSet 类型大 Key（如包含大量元素的集合）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%A0%E9%99%A4%E5%A4%A7-Key-%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="toc-number">17.7.3.2.</span> <span class="toc-text">二、删除大 Key 的特殊处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADkey"><span class="toc-number">17.8.</span> <span class="toc-text">什么是热key?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E5%92%8C-mysql-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">17.9.</span> <span class="toc-text">如何保证 redis 和 mysql 数据缓存一致性问题?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99%EF%BC%9A%E4%BC%98%E5%85%88-%E2%80%9C%E5%88%A0%E7%BC%93%E5%AD%98%E2%80%9D%EF%BC%8C%E8%80%8C%E9%9D%9E-%E2%80%9C%E6%9B%B4%E7%BC%93%E5%AD%98%E2%80%9D"><span class="toc-number">17.9.1.</span> <span class="toc-text">一、核心原则：优先 “删缓存”，而非 “更缓存”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BB%E6%B5%81%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3"><span class="toc-number">17.9.2.</span> <span class="toc-text">二、主流方案详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F%EF%BC%88Cache-Aside-Pattern%EF%BC%89%EF%BC%9A%E5%85%88%E6%9B%B4-DB%EF%BC%8C%E5%86%8D%E5%88%A0%E7%BC%93%E5%AD%98"><span class="toc-number">17.9.2.1.</span> <span class="toc-text">1. 旁路缓存模式（Cache-Aside Pattern）：先更 DB，再删缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%85%88%E5%88%A0%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4-DB-%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0"><span class="toc-number">17.9.2.2.</span> <span class="toc-text">2. 先删缓存，再更 DB + 延迟双删</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8E-Binlog-%E7%9A%84%E5%BC%82%E6%AD%A5%E5%90%8C%E6%AD%A5%EF%BC%88Canal-%E6%96%B9%E6%A1%88%EF%BC%89"><span class="toc-number">17.9.2.3.</span> <span class="toc-text">3. 基于 Binlog 的异步同步（Canal 方案）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%EF%BC%9A%E5%8A%A0%E9%94%81-%E5%8F%8C%E5%86%99"><span class="toc-number">17.9.2.4.</span> <span class="toc-text">4. 强一致性方案：加锁 + 双写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BF%85%E5%8A%A0%E5%85%9C%E5%BA%95%EF%BC%9A%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">17.9.3.</span> <span class="toc-text">三、必加兜底：缓存过期时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E6%98%AF%E4%BB%80%E4%B9%88-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">17.10.</span> <span class="toc-text">缓存雪崩、击穿、穿透是什么?怎么解决?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">17.11.</span> <span class="toc-text">布隆过滤器原理介绍一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BB%A5%E5%8F%8A%E8%B6%85%E5%8D%96%E7%8E%B0%E8%B1%A1"><span class="toc-number">17.12.</span> <span class="toc-text">如何设计秒杀场景处理高并发以及超卖现象?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E8%B6%85%E5%8D%96%EF%BC%9A%E5%BA%93%E5%AD%98%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">17.12.1.</span> <span class="toc-text">防超卖：库存操作的原子性与一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BA%93%E5%AD%98%E9%A2%84%E7%83%AD%EF%BC%9ARedis-%E9%A2%84%E5%AD%98%E5%BA%93%E5%AD%98%EF%BC%88%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%EF%BC%89"><span class="toc-number">17.12.1.1.</span> <span class="toc-text">1. 库存预热：Redis 预存库存（快速判断）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Redis-%E5%8E%9F%E5%AD%90%E6%89%A3%E5%87%8F%EF%BC%9A%E6%8B%A6%E6%88%AA%E8%B6%85%E9%87%8F%E8%AF%B7%E6%B1%82%EF%BC%88%E6%A0%B8%E5%BF%83%E9%98%B2%E8%B6%85%E5%8D%96%EF%BC%89"><span class="toc-number">17.12.1.2.</span> <span class="toc-text">2. Redis 原子扣减：拦截超量请求（核心防超卖）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-MySQL-%E6%9C%80%E7%BB%88%E6%A0%A1%E9%AA%8C%EF%BC%9A%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E5%85%9C%E5%BA%95%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">17.12.1.3.</span> <span class="toc-text">3. MySQL 最终校验：保证数据一致性（兜底机制）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%BA%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%BB%B4%E6%8A%A4"><span class="toc-number">17.12.1.4.</span> <span class="toc-text">4. 库存一致性维护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E5%A6%82-Redis-%E9%87%8C%E9%9D%A2%E6%9C%89-1-%E4%BA%BF%E4%B8%AA-key%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89-10w-%E4%B8%AA-key-%E6%98%AF%E4%BB%A5-%E6%9F%90%E4%B8%AA%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%89%8D%E7%BC%80%E5%BC%80%E5%A4%B4%E7%9A%84%EF%BC%8C-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AE%83%E4%BB%AC%E5%85%A8%E9%83%A8%E6%89%BE%E5%87%BA%E6%9D%A5%EF%BC%9F"><span class="toc-number">17.13.</span> <span class="toc-text">假如 Redis 里面有 1 亿个   key，其中有 10w 个 key 是以 某个固定的已知的前缀开头的， 如何将它们全部找出来？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E9%87%8C%E6%9C%89-2000w-%E6%95%B0%E6%8D%AE%EF%BC%8C-redis-%E4%B8%AD%E5%8F%AA%E5%AD%98-20w-%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82-%E4%BD%95%E4%BF%9D%E8%AF%81-redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9-%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">17.14.</span> <span class="toc-text">MySQL 里有 2000w 数据，  redis 中只存 20w 的数据，如 何保证 redis 中的数据都是热点 数据？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/49aedbef.html" title="如何设计一个秒杀场景？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/pH7DOX5rqdLCk4b.jpg?_r_=d0373d96-8ded-1918-75db-bc79c24292e2" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何设计一个秒杀场景？"/></a><div class="content"><a class="title" href="/posts/49aedbef.html" title="如何设计一个秒杀场景？">如何设计一个秒杀场景？</a><time datetime="2025-11-01T09:41:03.000Z" title="发表于 2025-11-01 17:41:03">2025-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/211c5c1e.html" title="工具命令"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=2f392bd0-33ea-48ed-ad11-b97812f2b595" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="工具命令"/></a><div class="content"><a class="title" href="/posts/211c5c1e.html" title="工具命令">工具命令</a><time datetime="2025-11-01T09:41:03.000Z" title="发表于 2025-11-01 17:41:03">2025-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fe3c2cd2.html" title="分布式"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=f5e7a396-b897-1dc8-6b17-1c570debcbea" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式"/></a><div class="content"><a class="title" href="/posts/fe3c2cd2.html" title="分布式">分布式</a><time datetime="2025-11-01T01:50:36.000Z" title="发表于 2025-11-01 09:50:36">2025-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fec99276.html" title="消息队列"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=ca0f0085-c76b-b460-1bbd-516b99f821e8" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="消息队列"/></a><div class="content"><a class="title" href="/posts/fec99276.html" title="消息队列">消息队列</a><time datetime="2025-10-31T05:50:36.000Z" title="发表于 2025-10-31 13:50:36">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a0d0ac1c.html" title="Mybatis面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=9f73e914-1418-a81d-00c3-4cc2d3cc9b8b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis面试题"/></a><div class="content"><a class="title" href="/posts/a0d0ac1c.html" title="Mybatis面试题">Mybatis面试题</a><time datetime="2025-10-30T04:31:36.000Z" title="发表于 2025-10-30 12:31:36">2025-10-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC-brightgreen?style=social&amp;logo=appveyor&amp;logoColor=blue&amp;logoSize=auto&amp;label=%E5%8C%97%E5%B7%9D&amp;labelColor=white&amp;color=white" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2021 - 2025 By <a class="footer-bar-link" href="/" title="北川" target="_blank">北川</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://gukeyang.github.io" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Docker/" style="font-size: 0.88rem;">Docker<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">JVM调优<sup>1</sup></a><a href="/tags/Kafka/" style="font-size: 0.88rem;">Kafka<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>1</sup></a><a href="/tags/Mybatis/" style="font-size: 0.88rem;">Mybatis<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 0.88rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redis/" style="font-size: 0.88rem;">Redis<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/SpringMVC/" style="font-size: 0.88rem;">SpringMVC<sup>1</sup></a><a href="/tags/Springboot/" style="font-size: 0.88rem;">Springboot<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/nacos/" style="font-size: 0.88rem;">nacos<sup>1</sup></a><a href="/tags/seata/" style="font-size: 0.88rem;">seata<sup>1</sup></a><a href="/tags/sentinel/" style="font-size: 0.88rem;">sentinel<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 0.88rem;">复习<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>1</sup></a><a href="/tags/%E5%BA%93%E5%AD%98/" style="font-size: 0.88rem;">库存<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E7%94%B5%E5%95%86/" style="font-size: 0.88rem;">电商<sup>1</sup></a><a href="/tags/%E7%A7%92%E6%9D%80/" style="font-size: 0.88rem;">秒杀<sup>1</sup></a><a href="/tags/%E8%AE%A2%E5%8D%95/" style="font-size: 0.88rem;">订单<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96/" style="font-size: 0.88rem;">超卖<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 0.88rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8152976493&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2021 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 北川 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://img.shields.io/badge/%E4%B8%8B%E7%8F%AD%E5%93%88%E7%9A%AE-brightgreen?style=social&amp;logo=appveyor&amp;logoColor=blue&amp;logoSize=auto&amp;label=%E5%8C%97%E5%B7%9D&amp;labelColor=white&amp;color=white";
      img.title = "下班了就该开开心心的玩耍，嘿嘿~";
      img.alt = "下班了就该开开心心的玩耍，嘿嘿~";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
      appKey: 'TjKeHNK7GJrGTYuKYzGzh8yg',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: {"2023":"https://i0.hdslb.com/bfs/emote/fa6dda8b876ed38609de38aa604be5ad109b8591.png","14周年":"https://i0.hdslb.com/bfs/emote/53148f85bb7e2d8bada8cea57ee4b1f36f48237d.png","兔年":"https://i0.hdslb.com/bfs/emote/9cb6ee2c42986c56ec361d21d5ccbd096aefab0a.png","脱单doge":"https://i0.hdslb.com/bfs/emote/bf7e00ecab02171f8461ee8cf439c73db9797748.png","微笑":"https://i0.hdslb.com/bfs/emote/685612eadc33f6bc233776c6241813385844f182.png","微笑-春节":"https://i0.hdslb.com/bfs/emote/f32e5d367c81fbb88b54d7fe46366de04fe4f38f.png","微笑-愚人节":"https://i0.hdslb.com/bfs/emote/774d19d2416eb5b30ac66b02ac580b1b0ca92a80.png","微笑-愚人节2":"https://i0.hdslb.com/bfs/emote/ff45294fbd469ed51eab492e15b8bc7f8e755f14.png","口罩":"https://i0.hdslb.com/bfs/emote/3ad2f66b151496d2a5fb0a8ea75f32265d778dd3.png","doge":"https://i0.hdslb.com/bfs/emote/3087d273a78ccaff4bb1e9972e2ba2a7583c9f11.png","doge-春节":"https://i0.hdslb.com/bfs/emote/feb9abf68df628803ff69a244e744470c2b7e136.png","doge-圣诞":"https://i0.hdslb.com/bfs/emote/1afb5eb96846e0876071eeecb47be95dbf55f08d.png","doge-愚人节":"https://i0.hdslb.com/bfs/emote/8ab62b33061d20bc27beec798a2f73c639e8bb6e.png","doge-愚人节2":"https://i0.hdslb.com/bfs/emote/94460b4e92163c4ca88684b1830ca182d56ddea7.png","妙啊":"https://i0.hdslb.com/bfs/emote/b4cb77159d58614a9b787b91b1cd22a81f383535.png","妙啊-春节":"https://i0.hdslb.com/bfs/emote/692f196da6a623a1634ea305618d37709c2c87f0.png","妙啊-圣诞":"https://i0.hdslb.com/bfs/emote/1cdb10e4b6c6743a1ec96f1579e3ef3045a8f225.png","妙啊-愚人节":"https://i0.hdslb.com/bfs/emote/5675a5d2f3e7fb6b29db0ca8c7703237a18c4271.png","妙啊-愚人节2":"https://i0.hdslb.com/bfs/emote/7b55232e0733afe509d4ac6282d7e604f6f2064f.png","OK":"https://i0.hdslb.com/bfs/emote/4683fd9ffc925fa6423110979d7dcac5eda297f4.png","OK-春节":"https://i0.hdslb.com/bfs/emote/ad17fceba45996104c8b8e2e3f4efd7e2f588368.png","OK-圣诞":"https://i0.hdslb.com/bfs/emote/75d1c99cce001d6d103a8fd406616be9f51621ab.png","OK-愚人节":"https://i0.hdslb.com/bfs/emote/76cc9da7f4a054cb02aad900f0ca3d3fda9c9667.png","OK-愚人节2":"https://i0.hdslb.com/bfs/emote/4ab30d0c384aa7fb112d6078777d46f73797869b.png","星星眼":"https://i0.hdslb.com/bfs/emote/63c9d1a31c0da745b61cdb35e0ecb28635675db2.png","星星眼-春节":"https://i0.hdslb.com/bfs/emote/f6f01068ac7f6548779b0e16daa61974f9299b17.png","星星眼-圣诞":"https://i0.hdslb.com/bfs/emote/195641c30c55f34f9cd82c5e5c32d66a425c7723.png","星星眼-愚人节":"https://i0.hdslb.com/bfs/emote/270e85c95c1ad919848b415601ed3a879bd08127.png","星星眼-愚人节2":"https://i0.hdslb.com/bfs/emote/99471a235923d29c00fa9fc46b82e74196f99722.png","辣眼睛":"https://i0.hdslb.com/bfs/emote/35d62c496d1e4ea9e091243fa812866f5fecc101.png","辣眼睛-春节":"https://i0.hdslb.com/bfs/emote/1ad7c9d351bd64332cc8520c165ee0b32a6e82fa.png","辣眼睛-圣诞":"https://i0.hdslb.com/bfs/emote/8080adfe5acdfd0b6b09bd91db24ea7334ac7b44.png","辣眼睛-愚人节":"https://i0.hdslb.com/bfs/emote/65ed9509df4d509a1cdf22e75a6d3b708f4e9afb.png","辣眼睛-愚人节2":"https://i0.hdslb.com/bfs/emote/60fcc72634bc1d2ad612a18b46256d5d50804ca2.png","吃瓜":"https://i0.hdslb.com/bfs/emote/4191ce3c44c2b3df8fd97c33f85d3ab15f4f3c84.png","吃瓜-春节":"https://i0.hdslb.com/bfs/emote/fbd58fe2465d84d32f37800af0fe6f25711ef397.png","吃瓜-圣诞":"https://i0.hdslb.com/bfs/emote/aa6a3022e47b441c7f84d02cacc063a728a561e0.png","吃瓜-愚人节":"https://i0.hdslb.com/bfs/emote/f05344578512ef18878de01d188657fbf81d31c8.png","吃瓜-愚人节2":"https://i0.hdslb.com/bfs/emote/39a3f88f2232bdd8b8116d952060c72fcf093b55.png","滑稽":"https://i0.hdslb.com/bfs/emote/d15121545a99ac46774f1f4465b895fe2d1411c3.png","滑稽-春节":"https://i0.hdslb.com/bfs/emote/e56b466b43dd6930756d5caf4c22bef4f963dd35.png","滑稽-圣诞":"https://i0.hdslb.com/bfs/emote/5874276ea716d0e9797f827dcfca4332acf8f0de.png","滑稽-愚人节":"https://i0.hdslb.com/bfs/emote/e8c1b263949c2617e6395b190d185b2f8cdf0747.png","滑稽-愚人节2":"https://i0.hdslb.com/bfs/emote/1d44d848b82fe0fcbd4d6f23e3c4a26a0fe4f40f.png","呲牙":"https://i0.hdslb.com/bfs/emote/b5a5898491944a4268360f2e7a84623149672eb6.png","呲牙-春节":"https://i0.hdslb.com/bfs/emote/6ae3b1008d2fee7e15b5eb447b2ccff18e664b88.png","呲牙-圣诞":"https://i0.hdslb.com/bfs/emote/ae4395c1e29e9a2db0c9ccc4c0db05c414816e68.png","呲牙-愚人节":"https://i0.hdslb.com/bfs/emote/299e5867bb79f42d8553023909f42e89707cb500.png","呲牙-愚人节2":"https://i0.hdslb.com/bfs/emote/3688061f6a90c8559dc4663f4d4971ea27d0c014.png","打call":"https://i0.hdslb.com/bfs/emote/431432c43da3ee5aab5b0e4f8931953e649e9975.png","打call-春节":"https://i0.hdslb.com/bfs/emote/bf990016e43b7111cab4566dea194ba837a1a88f.png","打call-圣诞":"https://i0.hdslb.com/bfs/emote/2b04dd2d0e55d978ee485e1f7f3c5e355493ab78.png","打call-愚人节":"https://i0.hdslb.com/bfs/emote/49240d8643d7702519fc4cc468e0003a7623c0e3.png","打call-愚人节2":"https://i0.hdslb.com/bfs/emote/7ffaa98f9f49489022815e38dbcb1a04677a8f13.png","歪嘴":"https://i0.hdslb.com/bfs/emote/4384050fbab0586259acdd170b510fe262f08a17.png","歪嘴-愚人节":"https://i0.hdslb.com/bfs/emote/6cc4c091d3f2cc540f64d8f10ffe516fd2f4ea2b.png","歪嘴-愚人节2":"https://i0.hdslb.com/bfs/emote/f24a5cd8e8400a3ab850ce68ac495fde66a03b64.png","调皮":"https://i0.hdslb.com/bfs/emote/8290b7308325e3179d2154327c85640af1528617.png","调皮-愚人节":"https://i0.hdslb.com/bfs/emote/a09481ceb0644f799d94805446fd52dce775b022.png","调皮-愚人节2":"https://i0.hdslb.com/bfs/emote/0da0b2049a4f7b310e3992afbcb7367b81707824.png","豹富":"https://i0.hdslb.com/bfs/emote/3d1dbe52ea16e12ff7b1c371196f728a4097fb33.png","嗑瓜子":"https://i0.hdslb.com/bfs/emote/28a91da1685d90124cfeead74622e1ebb417c0eb.png","嗑瓜子-春节":"https://i0.hdslb.com/bfs/emote/d2f9910f2d6e52ead3bf1ee29754cd1176f5fc2e.png","笑哭":"https://i0.hdslb.com/bfs/emote/c3043ba94babf824dea03ce500d0e73763bf4f40.png","捂脸-圣诞":"https://i0.hdslb.com/bfs/emote/9af59557383770c398daac81583e6c4d27d83da7.png","笑哭-春节":"https://i0.hdslb.com/bfs/emote/29ce59fb7f14351d195609ef297d30e336bdb240.png","藏狐":"https://i0.hdslb.com/bfs/emote/ba0937ef6f3ccca85e2e0047e6263f3b4da37201.png","脸红":"https://i0.hdslb.com/bfs/emote/0922c375da40e6b69002bd89b858572f424dcfca.png","脸红-旧":"https://i0.hdslb.com/bfs/emote/50cb2606c285614f5786bd387c4f00dff923c82b.png","给心心":"https://i0.hdslb.com/bfs/emote/1597302b98827463f5b75c7cac1f29ea6ce572c4.png","嘟嘟":"https://i0.hdslb.com/bfs/emote/abd7404537d8162720ccbba9e0a8cdf75547e07a.png","哦呼":"https://i0.hdslb.com/bfs/emote/362bded07ea5434886271d23fa25f5d85d8af06c.png","喜欢":"https://i0.hdslb.com/bfs/emote/8a10a4d73a89f665feff3d46ca56e83dc68f9eb8.png","酸了":"https://i0.hdslb.com/bfs/emote/92b1c8cbceea3ae0e8e32253ea414783e8ba7806.png","嫌弃":"https://i0.hdslb.com/bfs/emote/de4c0783aaa60ec03de0a2b90858927bfad7154b.png","害羞":"https://i0.hdslb.com/bfs/emote/9d2ec4e1fbd6cb1b4d12d2bbbdd124ccb83ddfda.png","大哭":"https://i0.hdslb.com/bfs/emote/2caafee2e5db4db72104650d87810cc2c123fc86.png","疑惑":"https://i0.hdslb.com/bfs/emote/b7840db4b1f9f4726b7cb23c0972720c1698d661.png","喜极而泣":"https://i0.hdslb.com/bfs/emote/485a7e0c01c2d70707daae53bee4a9e2e31ef1ed.png","笑":"https://i0.hdslb.com/bfs/emote/81edf17314cea3b48674312b4364df44d5c01f17.png","偷笑":"https://i0.hdslb.com/bfs/emote/6c49d226e76c42cd8002abc47b3112bc5a92f66a.png","惊讶":"https://i0.hdslb.com/bfs/emote/f8e9a59cad52ae1a19622805696a35f0a0d853f3.png","捂脸":"https://i0.hdslb.com/bfs/emote/6921bb43f0c634870b92f4a8ad41dada94a5296d.png","阴险":"https://i0.hdslb.com/bfs/emote/ba8d5f8e7d136d59aab52c40fd3b8a43419eb03c.png","呆":"https://i0.hdslb.com/bfs/emote/33ad6000d9f9f168a0976bc60937786f239e5d8c.png","抠鼻":"https://i0.hdslb.com/bfs/emote/cb89184c97e3f6d50acfd7961c313ce50360d70f.png","大笑":"https://i0.hdslb.com/bfs/emote/ca94ad1c7e6dac895eb5b33b7836b634c614d1c0.png","惊喜":"https://i0.hdslb.com/bfs/emote/0afecaf3a3499479af946f29749e1a6c285b6f65.png","无语":"https://i0.hdslb.com/bfs/emote/44667b7d9349957e903b1b62cb91fb9b13720f04.png","点赞":"https://i0.hdslb.com/bfs/emote/1a67265993913f4c35d15a6028a30724e83e7d35.png","鼓掌":"https://i0.hdslb.com/bfs/emote/895d1fc616b4b6c830cf96012880818c0e1de00d.png","尴尬":"https://i0.hdslb.com/bfs/emote/cb321684ed5ce6eacdc2699092ab8fe7679e4fda.png","灵魂出窍":"https://i0.hdslb.com/bfs/emote/43d3db7d97343c01b47e22cfabeca84b4251f35a.png","委屈":"https://i0.hdslb.com/bfs/emote/d2f26cbdd6c96960320af03f5514c5b524990840.png","傲娇":"https://i0.hdslb.com/bfs/emote/010540d0f61220a0db4922e4a679a1d8eca94f4e.png","疼":"https://i0.hdslb.com/bfs/emote/905fd9a99ec316e353b9bd4ecd49a5f0a301eabf.png","冷":"https://i0.hdslb.com/bfs/emote/cb0ebbd0668640f07ebfc0e03f7a18a8cd00b4ed.png","热":"https://i0.hdslb.com/bfs/emote/4e58a2a6f5f1580ac33df2d2cf7ecad7d9ab3635.png","生病":"https://i0.hdslb.com/bfs/emote/0f25ce04ae1d7baf98650986454c634f6612cb76.png","捂眼":"https://i0.hdslb.com/bfs/emote/c5c6d6982e1e53e478daae554b239f2b227b172b.png","嘘声":"https://i0.hdslb.com/bfs/emote/e64af664d20716e090f10411496998095f62f844.png","思考":"https://i0.hdslb.com/bfs/emote/cfa9b7e89e4bfe04bbcd34ccb1b0df37f4fa905c.png","再见":"https://i0.hdslb.com/bfs/emote/fc510306bae26c9aec7e287cdf201ded27b065b9.png","翻白眼":"https://i0.hdslb.com/bfs/emote/eba54707c7168925b18f6f8b1f48d532fe08c2b1.png","哈欠":"https://i0.hdslb.com/bfs/emote/888d877729cbec444ddbd1cf4c9af155a7a06086.png","奋斗":"https://i0.hdslb.com/bfs/emote/bb2060c15dba7d3fd731c35079d1617f1afe3376.png","墨镜":"https://i0.hdslb.com/bfs/emote/3a03aebfc06339d86a68c2d893303b46f4b85771.png","难过":"https://i0.hdslb.com/bfs/emote/a651db36701610aa70a781fa98c07c9789b11543.png","撇嘴":"https://i0.hdslb.com/bfs/emote/531863568e5668c5ac181d395508a0eeb1f0cda4.png","抓狂":"https://i0.hdslb.com/bfs/emote/4c87afff88c22439c45b79e9d2035d21d5622eba.png","生气":"https://i0.hdslb.com/bfs/emote/3195714219c4b582a4fb02033dd1519913d0246d.png","水稻":"https://i0.hdslb.com/bfs/emote/d530fcaa5100ba12a17a79b55bad342d530c54e3.png","奶茶干杯":"https://i0.hdslb.com/bfs/emote/d5a491990be551ce69f9660da948050df4eab331.png","汤圆":"https://i0.hdslb.com/bfs/emote/93609633a9d194cf336687eb19c01dca95bde719.png","锦鲤":"https://i0.hdslb.com/bfs/emote/643d6c19c8164ffd89e3e9cdf093cf5d773d979c.png","锦鲤-愚人节2":"https://i0.hdslb.com/bfs/emote/51b05d4c678f3880499f1cf2c5742c334cdd0a72.png","福到了":"https://i0.hdslb.com/bfs/emote/5de5373d354c373cf1617b6b836f3a8d53c5a655.png","鸡腿":"https://i0.hdslb.com/bfs/emote/c7860392815d345fa69c4f00ef18d67dccfbd574.png","雪花":"https://i0.hdslb.com/bfs/emote/a41813c4edf8782047e172c884ebd4507ce5e449.png","视频卫星":"https://i0.hdslb.com/bfs/emote/dce6fc7d6dfeafff01241924db60f8251cca5307.png","干杯":"https://i0.hdslb.com/bfs/emote/8da12d5f55a2c7e9778dcc05b40571979fe208e6.png","黑洞":"https://i0.hdslb.com/bfs/emote/e90ec4c799010f25391179118ccd9f66b3b279ba.png","黑洞2":"https://i0.hdslb.com/bfs/emote/c4e9f0e3f35961d5037cb071b16ddba2170b262c.png","爱心":"https://i0.hdslb.com/bfs/emote/ed04066ea7124106d17ffcaf75600700e5442f5c.png","胜利":"https://i0.hdslb.com/bfs/emote/b49fa9f4b1e7c3477918153b82c60b114d87347c.png","加油":"https://i0.hdslb.com/bfs/emote/c7aaeacb21e107292d3bb053e5abde4a4459ed30.png","抱拳":"https://i0.hdslb.com/bfs/emote/89516218158dbea18ab78e8873060bf95d33bbbe.png","响指":"https://i0.hdslb.com/bfs/emote/1b5c53cf14336903e1d2ae3527ca380a1256a077.png","保佑":"https://i0.hdslb.com/bfs/emote/fafe8d3de0dc139ebe995491d2dac458a865fb30.png","福":"https://i0.hdslb.com/bfs/emote/802429a301ac5b35a0480d9526a070ce67cd8097.png","支持":"https://i0.hdslb.com/bfs/emote/3c210366a5585706c09d4c686a9d942b39feeb50.png","拥抱":"https://i0.hdslb.com/bfs/emote/41780a4254750cdaaccb20735730a36044e98ef3.png","跪了":"https://i0.hdslb.com/bfs/emote/f2b3aee7e521de7799d4e3aa379b01be032698ac.png","怪我咯":"https://i0.hdslb.com/bfs/emote/07cc6077f7f7d75b8d2c722dd9d9828a9fb9e46d.png","老鼠":"https://i0.hdslb.com/bfs/emote/8e6fb491eb1bb0d5862e7ec8ccf9a3da12b6c155.png","牛年":"https://i0.hdslb.com/bfs/emote/9275275ff1f2659310648221107d20bc4970f106.png","三星堆":"https://i0.hdslb.com/bfs/emote/fc7dadaa6986e75b813aa26f3eff3281d5f1a6d1.png","桃源-给花花":"https://i0.hdslb.com/bfs/emote/085d41d0fa25453b58fdc87dc2df538183fea11e.png","桃源-缘分":"https://i0.hdslb.com/bfs/emote/cf1c441507689342713623965035f9bed72b1b17.png","桃源-傲娇":"https://i0.hdslb.com/bfs/emote/ce8314c9c2cfdbe235c239c28b819698e29a02d3.png","桃源-欢呼":"https://i0.hdslb.com/bfs/emote/1f439878d8160bd64a4464904064a10df880c921.png","桃源-乖巧":"https://i0.hdslb.com/bfs/emote/57d087b6437002c2ca9e225dcac0ef226d1f2654.png","洛天依":"https://i0.hdslb.com/bfs/emote/9fe06f3594d9afaf4ee2b74770f1c3086ae0ba11.png","坎公骑冠剑-吃鸡":"https://i0.hdslb.com/bfs/emote/c4248a7b6ab326d66c83fd1fb58f1a50f99df332.png","坎公骑冠剑-钻石":"https://i0.hdslb.com/bfs/emote/0b97c7e50e0cc963370e62fbb9b55f51bbe7f8ab.png","坎公骑冠剑-无语":"https://i0.hdslb.com/bfs/emote/80eba0ce64c3fc1279b4daede2f1979cb2380e78.png","来古-沉思":"https://i0.hdslb.com/bfs/emote/4ee07ff03266d62b246be0b950bebb2abf3d997c.png","来古-呆滞":"https://i0.hdslb.com/bfs/emote/9a70b365e523f2379f395031ceefcebb75a45903.png","来古-疑问":"https://i0.hdslb.com/bfs/emote/032fdc0d9d9fe6334776f6c39518a959b73b98f4.png","来古-震撼":"https://i0.hdslb.com/bfs/emote/8b40f228675602a317d32007de6b795c101135ec.png","来古-注意":"https://i0.hdslb.com/bfs/emote/4b671ba32a2581cf40e5cd41c67b111eb8010de0.png","初音未来-大笑":"https://i0.hdslb.com/bfs/emote/8e7f71cda83ce407b0684702983399f8ed982f17.png","原神-哇":"https://i0.hdslb.com/bfs/emote/8188ddf95bace929d382c7a83214afde79d83bfc.png","原神-哼":"https://i0.hdslb.com/bfs/emote/91ed33b74bc36873c3ac8b2648f70d7ab6d8ab78.png","原神-嗯":"https://i0.hdslb.com/bfs/emote/8b0a87e414f453a29730b6e0f45ca61f2f898688.png","原神-欸嘿":"https://i0.hdslb.com/bfs/emote/8fba438fcbe0550877b04efd768d857082307c5e.png","原神-喝茶":"https://i0.hdslb.com/bfs/emote/1de5789fbb3526ef7823c54db7081790a38e7044.png","原神-生气":"https://i0.hdslb.com/bfs/emote/90a38c34742899f8e84138ed55f56cad3ba611fb.png","保卫萝卜-白眼":"https://i0.hdslb.com/bfs/emote/9fce63f38288700bf7be84f3be336cf895ba0902.png","保卫萝卜-笔芯":"https://i0.hdslb.com/bfs/emote/5ff2ed5cb71b02010018cc5910ac7052a03769af.png","保卫萝卜-哭哭":"https://i0.hdslb.com/bfs/emote/7d249f7c990111d3e2982f7477af15b7eb29cbd9.png","保卫萝卜-哇":"https://i0.hdslb.com/bfs/emote/5f2370e561c32d841245f7b1aab2eef43aeb9544.png","保卫萝卜-问号":"https://i0.hdslb.com/bfs/emote/41eb93f09fc4a4d0692a310e8a1f85ba60e96060.png","无悔华夏-不愧是你":"https://i0.hdslb.com/bfs/emote/c58002c32ee78d45366e126f294cb3149dd64ac2.png","无悔华夏-吃瓜":"https://i0.hdslb.com/bfs/emote/273dcff577551bafff4f1eae18561f871e73a6ba.png","无悔华夏-达咩":"https://i0.hdslb.com/bfs/emote/cffab383f47bab7f6736ba9c8d6ac098113410d9.png","无悔华夏-点赞":"https://i0.hdslb.com/bfs/emote/b0f2e8db405ec667c3e6aaabd7c15155b6ea8710.png","无悔华夏-好耶":"https://i0.hdslb.com/bfs/emote/324cd79784aeb37dbf2f47f68bbe8ed5d01f975e.png","奥比岛-搬砖":"https://i0.hdslb.com/bfs/emote/1fab697214918d91087373a999cc7ef8040ddf85.png","奥比岛-点赞":"https://i0.hdslb.com/bfs/emote/fb0b476fe2ff30cd59385ea7d616627ac114161f.png","奥比岛-击爪":"https://i0.hdslb.com/bfs/emote/35bba1bb8f164c5e844155548438248e6eaa8382.png","奥比岛-委屈":"https://i0.hdslb.com/bfs/emote/fda155e7c33b40dbb94c24644e0635d47b6ef3cc.png","奥比岛-喜欢":"https://i0.hdslb.com/bfs/emote/ed64e0c81ee194138bd9df30c65077ed978fb88c.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://4GK2IcRZ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
        "X-LC-Key": 'TjKeHNK7GJrGTYuKYzGzh8yg',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="//code.tidio.co/4nifo6zdbrmyjsngh2yzxwbnlhrvshrf.js" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>